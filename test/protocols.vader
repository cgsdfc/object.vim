" Test setattr()
"
Execute(setattr() should set attribute with a Dict);
let bar = {}
call object#setattr(bar, 'weight', 10)
AssertEqual bar.weight, 10
call object#setattr(bar, 'weight', 'heavy')
AssertEqual bar.weight, 'heavy'

Execute(setattr() should throw WrongType when {object} is not a Dict or {name} is not a String);
let wrong_types = [[ 'str', 'attr'], [ {}, 1 ], [ 'str', 1 ]]

for [obj, name] in wrong_types
  AssertThrows call object#setattr(g:obj, g:name, 1)
  Assert g:vader_exception =~# 'ERROR(WrongType)'
endfor

Execute(setattr() should be able to hook into __setattr__());
let cls = { 'speed' : 100, 'duration' : 10 }
function! cls.__setattr__(name, val)
  if a:name is# 'speed'
    throw 'speed is readonly'
  endif
  if a:name is# 'duration' && a:val >= 0
    " Only accept positive duration
    let self.duration = a:val
  endif
endfunction

AssertThrows call object#setattr(g:cls, 'speed', 20)
Assert g:vader_exception is# 'speed is readonly'

call object#setattr(cls, 'duration', -1)
AssertEqual cls.duration, 10

call object#setattr(cls, 'duration', 20)
AssertEqual cls.duration, 20

"
" Test hasattr()
"

Execute(hasattr() returns 1 when object is a Dict and it has that attribute);
let obj = { 'count' : 22, 'line' : 100, 'pos' : 10 }
Assert object#hasattr(obj, 'count')
Assert object#hasattr(obj, 'line')
Assert object#hasattr(obj, 'pos')

Execute(hasattr() should return 0 when object is not a Dict or does not have that attribute);
Assert !object#hasattr([], 'length')
Assert !object#hasattr('', 'toupper')
Assert !object#hasattr(30, 'digits')

Assert !object#hasattr({'gender' : 'male'}, 'age')

Execute(hasattr() should throw WrongType with non-String name);
AssertThrows call object#hasattr({}, [])
Assert g:vader_exception =~# 'ERROR(WrongType)'

"
" repr()
"
Execute(repr() can hook into __repr__());
let cls = {}
function! cls.__repr__()
  return '<repr>'
endfunction

AssertEqual object#repr(cls), '<repr>'

Execute(repr() should fail back on string() when object has no __repr__());
let input = [
      \ ['1', 1],
      \ ["''", ''], 
      \ [ "{'name': 1}", {'name': 1}],
      \ ['[]', []],
      \ [ 'v:none', v:none],
      \ ['{}', {}],
      \ [ "'string'", 'string'],
      \ ]

for [should, x] in input
  AssertEqual should, object#repr(x) 
endfor

Execute(repr() should throw WrongType when __repr__ is not a Funcref);
let cls = { '__repr__': [] }

AssertThrows call object#repr(g:cls)
Assert g:vader_exception=~#'ERROR(WrongType)'

Execute(repr() should throw WrongType when __repr__() returns something not String);
let cls = {}
function! cls.__repr__()
  return []
endfunction

AssertThrows call object#repr(g:cls)
Assert g:vader_exception=~#'ERROR(WrongType)'

"
" Test len()
"
Execute(len() should use __len__() if available);
let cls = {}
function! cls.__len__()
  return 12
endfunction

AssertEqual 12, object#len(cls)

Execute(len() should use len() of Vim if obj is a Collection or String);
let input = [
      \ range(10),
      \ '123',
      \ { 'a': 1, 'b': 2, 'c': 3},
      \ ]

for x in input
  AssertEqual len(x), object#len(x)
endfor

Execute(len() should throw WrongType if the len of obj  cannot be determined);
let input = [
      \ 1,
      \ v:none,
      \ function('empty'),
      \ v:null,
      \ v:false,
      \ ]
if has('float')
  call add(input, 1.0)
endif

for X in input
  AssertThrows call object#len(g:X)
  Assert g:vader_exception =~# 'WrongType'
endfor

Execute(len() should throw WrongType if __len__() returns non-number);
let cls = {}
function! cls.__len__()
  return 'bad'
endfunction

AssertThrows call object#len(g:cls)
Assert g:vader_exception =~# 'WrongType'

"
" Test dir()
"
Execute(dir() should only accept Dict);
let input = [
      \ 1,
      \ 'str',
      \ [],
      \ ]

for x in input
  AssertThrows call object#dir(g:x)
  Assert g:vader_exception =~# 'WrongType'
endfor

Execute(dir() return keys() for ordinary Dict but hooks into __dir__());
let x = {
      \ 'root': '/path/to/somewhere/',
      \ 'has_permisson': 'true',
      \ 'last_access': '/path/to/somefile',
      \ 'refcnt': 10,
      \ }

AssertEqual keys(x), object#dir(x), 'if the Dict has no __dir__(), use key()'

let cls = {
      \ 'x': x
      \ }
function! cls.__dir__()
  return object#dir(self.x)
endfunction

AssertEqual keys(x), object#dir(cls)

" vim:ft=vim
