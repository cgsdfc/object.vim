Before;
" Fetch the dummy text as test input
let test_dir = fnamemodify(g:vader_file, ':h')
let lipsum_path = maktaba#path#Join([test_dir, 'data', 'lipsum.txt'])
let input = map(readfile(lipsum_path), 'split(v:val)')

Execute(Confirm the bitwidth of the Vim runtime);
let info = object#mapping#nrinfo()
Log printf('Bitwidth of Number %s', info.width)
Log printf('Max of Number %s', info.max)
Log printf('Has cryptv %s', has('cryptv')?'yes':'no')

"
" Test strhash_sha256() and strhash_djb2()
"

Execute(strhash_sha256() should always return non-negative nr);
for line in input
  for word in line
    let hash = object#mapping#strhash_sha256(word)
    Assert hash >= 0
  endfor
endfor

Execute(strhash_djb2() should always return non-negative nr);
for line in input
  for word in line
    let hash =object#mapping#strhash_djb2(word)
    Assert hash >= 0
  endfor
endfor

Execute(strhash_sha256() should be equal if the input values are equal);
for line in input
  for word in line
    let x = object#mapping#strhash_sha256(word)
    let y = object#mapping#strhash_sha256(word)
    AssertEqual x, y, 'strhash_sha256() should be a function!'
  endfor
endfor

Execute(strhash_djb2() should be equal if the input values are equal);
for line in input
  for word in line
    let x = object#mapping#strhash_djb2(word)
    let y = object#mapping#strhash_djb2(word)
    AssertEqual x, y, 'strhash_djb2() should be a function!'
  endfor
endfor

"
" Test hash()
"

Execute(hash(Number) should be non-negative);
for i in range(-500, 500)
  let hash = object#hash(i)
  Assert hash >= 0
endfor

Execute(hash() works with special variables);
let input = [ v:null, v:none, v:false, ]
for x in input
  AssertEqual 0, object#hash(x)
endfor
AssertEqual 1, object#hash(v:true)

Execute(hash() should treat Funcref as if they are string()'ed);
let input = [ 'empty', 'len', 'items', 'values' ]
for x in input
  let X = function(x)
  let hash = object#hash(X)
  AssertEqual hash, object#hash(string(X))
endfor

Execute(hash() should throw TypeError with Float, List and Dict without __hash__());
" Hashing Float is very complicated and no supported now plus the pitfalls of
" using a Float key.
let input = [ [], {}, ]
if has('float')
  call add(input, 1.0)
endif
for x in input
  AssertThrows call object#hash(g:x)
  Assert g:vader_exception =~# 'TypeError'
endfor

Execute(hash() should hook into __hash__);
let cls = {
      \ 'email': 'somebody@someplace.com',
      \ 'door': 213,
      \ }

function! cls.__hash__()
  return self.door
endfunction

AssertEqual cls.door, object#hash(cls)

function! cls.__hash__()
  return object#hash(self.email)
endfunction

AssertEqual object#hash(cls), object#hash(cls.email)

Execute(hash() should throw WrongType if __hash__ is not a Funcref or return something non-Number);
let cls = {
      \ '__hash__': 0
      \ }
AssertThrows call object#hash(g:cls)
Assert g:vader_exception =~# 'WrongType'

function! Hash() dict
  return 'not a number (NAN)'
endfunction

let cls.__hash__ = function('Hash')
AssertThrows call object#hash(g:cls)
Assert g:vader_exception =~# 'WrongType'

"
" Test getitem() and setitem()
"

Execute(getitem() works with String, List and Dict without __getitem__);
let input = [
      \ [ 'str', 0, 's' ],
      \ [ [ 1, 2, 3, ], 1, 2 ],
      \ [ { 'a': 1, 'b': 2 }, 'b', 2 ],
      \ ]
for [mapping, key, val] in input
  AssertEqual object#getitem(mapping, key), val
endfor

Execute(getitem() works with __getitem__);
let cls = { 'data': {} }
function! cls.__getitem__(key)
  return self.data[a:key]
endfunction

function! cls.add(x, val)
  let self.data[a:x] = a:val
endfunction

let input = [
      \ [ 'apple', 'red' ],
      \ [ 'banana', 'yellow' ],
      \ [ 'oringe', 'oringe' ],
      \ ]

for [key, val] in input
  call cls.add(key, val)
endfor

for [key, val] in input
  AssertEqual object#getitem(cls, key), val
endfor

Execute(getitem() throws TypeError if the type of obj doesn't support it);
let input = [
      \ '1', v:none, v:false, v:true, function('empty'), 
      \ ]
for X in input
  AssertThrows call object#getitem(g:x, 0)
  Assert g:vader_exception =~# 'TypeError'
endfor

Execute(getitem() throws WrongType if __getitem__ is not Funcref);
let cls = { '__getitem__' : 1 }
AssertThrows call object#getitem(g:cls, 2)
Assert g:vader_exception =~# 'WrongType'



"TODO: Draw some graph to show that the sha256/djb2 hash is well distributed.
" vim:ft=vim
