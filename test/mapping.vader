Before;
" Fetch the dummy text as test input
let test_dir = fnamemodify(g:vader_file, ':h')
let lipsum_path = maktaba#path#Join([test_dir, 'data', 'lipsum.txt'])
let input = map(readfile(lipsum_path), 'split(v:val)')

Execute(Confirm the bitwidth of the Vim runtime);
let info = object#mapping#nrinfo()
Log printf('Bitwidth of Number %s', info.width)
Log printf('Max of Number %s', info.max)
Log printf('Has cryptv %s', has('cryptv')?'yes':'no')

"
" Test strhash_sha256() and strhash_djb2()
"

Execute(strhash_sha256() should always return non-negative nr);
for line in input
  for word in line
    let hash = object#mapping#strhash_sha256(word)
    Assert hash >= 0
  endfor
endfor

Execute(strhash_djb2() should always return non-negative nr);
for line in input
  for word in line
    let hash =object#mapping#strhash_djb2(word)
    Assert hash >= 0
  endfor
endfor

Execute(strhash_sha256() should be equal if the input values are equal);
for line in input
  for word in line
    let x = object#mapping#strhash_sha256(word)
    let y = object#mapping#strhash_sha256(word)
    AssertEqual x, y, 'strhash_sha256() should be a function!'
  endfor
endfor

Execute(strhash_djb2() should be equal if the input values are equal);
for line in input
  for word in line
    let x = object#mapping#strhash_djb2(word)
    let y = object#mapping#strhash_djb2(word)
    AssertEqual x, y, 'strhash_djb2() should be a function!'
  endfor
endfor

"
" Test hash()
"

Execute(hash(Number) should be non-negative);
for i in range(-500, 500)
  let hash = object#hash(i)
  Assert hash >= 0
endfor

Execute(hash() with special variables);
let input = [ v:null, v:none, v:false, ]
for x in input
  AssertEqual 0, object#hash(x)
endfor
AssertEqual 1, object#hash(v:true)

Execute(hash() should throw TypeError with Float, List and Dict without __hash__());
" Hashing Float is very complicated and no supported now plus the pitfalls of
" using a Float key.
let input = [ [], {}, ]
if has('float')
  call add(input, 1.0)
endif
for x in input
  AssertThrows call object#hash(g:x)
  Assert g:vader_exception =~# 'TypeError'
endfor

Execute(hash() should hook into __hash__);
let cls = {
      \ 'email': 'somebody@someplace.com',
      \ 'door': 213,
      \ }

function! cls.__hash__()
  return self.door
endfunction

AssertEqual cls.door, object#hash(cls)

function! cls.__hash__()
  return object#hash(self.email)
endfunction

AssertEqual object#hash(cls), object#hash(cls.email)

Execute(hash() should throw WrongType if __hash__ is not a Funcref or return something non-Number);
let cls = {
      \ '__hash__': 0
      \ }
AssertThrows call object#hash(g:cls)
Assert g:vader_exception =~# 'WrongType'

function! Hash() dict
  return 'not a number (NAN)'
endfunction

let cls.__hash__ = function('Hash')
AssertThrows call object#hash(g:cls)
Assert g:vader_exception =~# 'WrongType'

"TODO: Draw some graph to show that the sha256/djb2 hash is well distributed.
" vim:ft=vim
