" vim: ft=vim

Execute (Throws TypeError if isinstance(obj, type) is false);
let X = object#class('X')
let Y = object#class('Y')
function! X.__init__()
  call object#super(g:Y, self, '__init__')
endfunction
AssertThrows call object#new(g:X)
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception

Execute (Throws TypeError if obj is not an object);
let Y = object#class('Y')
AssertThrows call object#super(g:Y, 1, '__init__')
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception

Execute (Throws TypeError if type is not a class);
let Y = object#class('Y')
let y = object#new(Y)
AssertThrows call object#super(1, g:y, '__init__')
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception

Execute (Throws WrongType or ValueError if name is not a String or an identifier);
let Y = object#class('Y')
let y = object#new(Y)
let input = [1, range(2), '$x']
for x in input
  AssertThrows call object#super(g:Y, g:y, g:x)
  Assert g:vader_exception =~# '\v\CWrongType|ValueError'
  Log g:vader_exception
endfor

Execute (Throws TypeError if there is no next class in MRO);
let object = object#object_()
let o = object#object()
AssertThrows call object#super(g:object, g:o, '__init__')
Log g:vader_exception

Execute (Throws AttributeError if name cannot be found);
let Y = object#class('Y')
let X = object#class('X', Y)
function! X.__init__()
  call object#super(g:Y, self, 'non_existing')
endfunction
AssertThrows call object#new(g:X)
Assert g:vader_exception =~# 'AttributeError'
Log g:vader_exception

"
" super_()
"

Execute (Does forward call to parents or siblings);
let X = object#class('X')
function! X.__init__()
  let self.x = 1
endfunction

let Y = object#class('Y', X)
function! Y.__init__()
  let sup = object#super_(g:Y, self)
  Log object#dir(sup)
  Assert sup.__self__ is# self
  Assert sup.__self_class__ is# object#type(self)
  Assert sup.__thisclass__ is# g:Y

  call sup.__init__()
  let self.y = 1
endfunction

let y = object#new(Y)
AssertEqual y.x, 1
AssertEqual y.y, 1
