" vim: ft=vim
" The file test the super() and super_() functions.
" Please refer to the document in super.vim for their differences.

"
" Common Behaviors
"

Before;
let object = object#object_()
let X = object#class('X')
let Y = object#class('Y')
let Z = object#class('Z')

let Base = object#class('Base')
let Sibling = object#class('Sibling')
let Derived = object#class('Derived', [Base, Sibling])


Execute (Throws TypeError if isinstance(obj, type) is false);
function! X.__init__()
  call object#super(g:Y, self)
endfunction

function! Y.__init__()
  call object#super_(g:X, self, '__init__')
endfunction

for Cls in [X, Y]
  AssertThrows call object#new(g:Cls)
  Log g:vader_exception
  Assert g:vader_exception =~# 'TypeError'
endfor

Execute (Throws TypeError if obj is not an object);

AssertThrows call object#super_(g:Y, 1, '__init__')
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception

AssertThrows call object#super(g:Y, 1)
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception


Execute (Throws TypeError if type is not a class);
let y = object#new(Y)

AssertThrows call object#super_(1, g:y, '__init__')
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception

AssertThrows call object#super(1, g:y)
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception


Execute (Throws TypeError if there is no next class in MRO);
let o = object#object()

AssertThrows call object#super_(g:object, g:o, '__init__')
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception

AssertThrows call object#super(g:object, g:o)
Assert g:vader_exception =~# 'TypeError'
Log g:vader_exception
" End of Common Beheviors.

"
" Test super_()
"

Execute (Forward call to direct parents and sibling);

function! Base.__init__()
  call object#super_(g:Base, self, '__init__')()
  let self.base = 1
endfunction

function! Sibling.__init__()
  call object#super_(g:Sibling, self, '__init__')()
  let self.sibling = 1
endfunction

function! Derived.__init__()
  call object#super_(g:Derived, self, '__init__')()
  let self.derived = 1
endfunction

let x = object#new(Derived)
AssertEqual [x.base, x.derived, x.sibling], [1, 1, 1]
let y = object#new(Base)
AssertEqual y.base, 1
let z = object#new(Sibling)
AssertEqual z.sibling, 1


Execute (Throws WrongType or ValueError if name is not a String or an identifier);
let y = object#new(Y)
let input = [1, range(2), '$x']

for x in input
  AssertThrows call object#super_(g:Y, g:y, g:x)
  Assert g:vader_exception =~# '\v\CWrongType|ValueError'
  Log g:vader_exception
endfor


Execute (Throws AttributeError if name cannot be found);
let X = object#class('X', Y)

function! X.__init__()
  call object#super_(g:X, self, 'non_existing')
endfunction

AssertThrows call object#new(g:X)
Assert g:vader_exception =~# 'AttributeError'
Log g:vader_exception


"
" Test super()
"

Execute (Has correct attributes);
let x = object#new(X)
let su = object#super(X, x)
Assert su.__self__ is# x
Assert su.__thisclass__ is# X
Assert su.__self_class__ is# x.__class__
Log object#repr(su)

Execute (Cache super object);
function! X.__init__()
  let su1 = object#super(g:X, self)
  Assert has_key(self, '__super__')
  let su2 = object#super(g:X, self)
  Assert su1 is# su2
endfunction

let x = object#new(X)

Execute (Forward call to direct parents and sibling);
function! Base.__init__()
  call object#super(g:Base, self).__init__()
  let self.base = 1
endfunction

function! Sibling.__init__()
  call object#super(g:Sibling, self).__init__()
  let self.sibling = 1
endfunction

function! Derived.__init__()
  call object#super(g:Derived, self).__init__()
  let self.derived = 1
endfunction

let x = object#new(Derived)
AssertEqual [x.base, x.derived, x.sibling], [1, 1, 1]
let y = object#new(Base)
AssertEqual y.base, 1
let z = object#new(Sibling)
AssertEqual z.sibling, 1


Execute (Cache works with classes with the same name);
let X1 = object#class('X')
let X2 = object#class('X')
let Derived = object#class('Derived', [X1, X2])

function! X1.__init__()
  call object#super(g:X1, self).__init__()
  let self.x1 = 1
endfunction

function! X2.__init__()
  call object#super(g:X2, self).__init__()
  let self.x2 = 1
endfunction

function! Derived.__init__()
  call object#super(g:Derived, self).__init__()
  let self.derived = 1
endfunction

let x = object#new(Derived)
AssertEqual [x.x1, x.x2, x.derived], [1, 1, 1]


Execute (Forward __repr__());
function! Base.__repr__()
  return 'Base instance'
endfunction

function! Derived.__repr__()
  return object#super(g:Derived, self).__repr__()
endfunction

let x = object#new(Derived)
AssertEqual object#repr(x), 'Base instance'

