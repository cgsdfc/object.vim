" vim:ft=vim

Include(Mode strings): file/mode-str.vader
Include(Attributes): file/attrs.vader

Before;
let lipsum = maktaba#path#Join([fnamemodify(g:vader_file, ':h'), 'data', 'lipsum.txt'])
let [mode_pattern, readable, writable, private_attrs] = object#file#patterns()
let f = object#open(lipsum)
let file_ = object#file_()
let bad_modes = [
      \ '+r', 'u', '@', ' r',
      \ "U+",
      \ ]
let data = split(repeat('a', 10))
let read_family = ['read', 'readline', 'readlines']
let write_family = ['write', 'writeline', 'writelines']

" Helper to put some text in a tempfile.
"
function! MakeTempfile(list)
  if !exists('g:tempfile_list')
    let g:tempfile_list = []
  endif
  let t = tempname()
  call writefile(a:list, t)
  call add(g:tempfile_list, t)
  return t
endfunction

function! MakeEmptyTempfile()
  return MakeTempfile([])
endfunction

function! MakeUnreadable(f)
  call setfperm(a:f , "-w-r-----")
endfunction

function! MakeUnwritable(f)
  call setfperm(a:f , "r--r-----")
endfunction

let writable_tempfile = MakeEmptyTempfile()
let  writable_fileobj = object#open(writable_tempfile, 'w')

After;
if exists('g:tempfile_list')
  call map(g:tempfile_list, 'delete(v:val)')
endif

"
" Hiding private attributes
"

Execute(private attrs not showing up);
for x in object#dir(f)
  Assert x !~# private_attrs
endfor

Execute(setattr() on file obj should throw AttributeError);
AssertThrows call object#setattr(g:f, 'x', 1)
Assert g:vader_exception =~# 'AttributeError.*no attribute'
for x in object#dir(f)
  AssertThrows call object#setattr(g:f, g:x, 1)
  Assert g:vader_exception =~# 'AttributeError.*readonly'
endfor

"
" Basic read* family.
"

Execute(read() returns all the lines);
let t = MakeTempfile(data)
try
  let f = object#open(t)
  AssertEqual f.read(), join(data, "\n")
catch
  Log v:exception
  Log 'Test failed'
endtry

Execute(a second call to f.read() should return '');
call f.read()
AssertEqual '', f.read()

Execute(f.readline() should retrieve each line without tailing NL);
let data = map(range(10), 'string(v:val)')
let t = MakeTempfile(data)
try
  let f = object#open(t, 'r')
  for x in data
    AssertEqual x, f.readline()
  endfor
  AssertEqual f.readline(), ''
catch
  Log v:exception
endtry

Execute(f.readlines() returns a list of all lines in f, which is equal to readfile());
AssertEqual f.readlines(), readfile(lipsum)
AssertEqual f.readlines(), []

"
" read*() throwing IOError
"

Execute(open()'ing an unreadable file throws IOError);
" chmod -r lipsum.txt
let t = MakeEmptyTempfile()
Assert maktaba#path#Exists(t)
try
  call MakeUnreadable(t)
  AssertThrows call object#open(g:t, 'r')
catch
  throw v:exception
endtry
Assert g:vader_exception =~# 'IOError'

Execute(Although open()'ed readable, f.read() and friends throw IOError if f becomes unreadable);
let t = MakeEmptyTempfile()
Assert filereadable(t)

let f = object#open(t)
" Every read() works fine.
call map(copy(read_family), 'f[v:val]()')

call MakeUnreadable(t)
for x in read_family
  AssertThrows call g:f[g:x]()
  Assert g:vader_exception =~# 'IOError'
endfor

Execute(open() throws ValueError for bad mode string);
for x in bad_modes
  AssertThrows call object#open(MakeEmptyTempfile(), g:x)
  Assert g:vader_exception =~# 'ValueError'
endfor

Execute(open() throws WrongType if name or mode is not String);
let bad = [
      \ [ 1, [] ],
      \ [ {}, 1 ],
      \]
for x in bad
  AssertThrows call call("object#open", g:x)
  Assert g:vader_exception =~# 'WrongType'
endfor

"
" write() family
"

Execute(a single call to write(str) writes a _line_ to f);
let data = repeat('b', 10)
call writable_fileobj.write(data)
call writable_fileobj.close()
AssertEqual [data], readfile(writable_tempfile)

Execute(write() concats to the current line of f);
let data = [ 'This ', 'is ', 'an ', 'apple.' ]
call map(copy(data), 'writable_fileobj.write(v:val)')
call writable_fileobj.close()
AssertEqual join(data, ''), readfile(writable_tempfile)[0]

Execute(multiple writeline()'s is equal to a single writelines());
" Make 2 empty tempfiles.
let samples = map(range(2), 'MakeEmptyTempfile()')

" Open all the tempfiles.
let files = map(copy(samples), 'object#open(v:val, "w")')

" Here is the difference
call files[0].writelines(data)
for x in data
  call files[1].writeline(x)
endfor

call map(files, 'v:val.close()')
call map(samples, 'readfile(v:val)')
AssertEqual samples[0], samples[1]

"
" Throwing behaviours of write() and friends.
"

Execute(write()/writeline() throws WrongType for non-String);
for x in ['write', 'writeline']
  AssertThrows call g:writable_fileobj[g:x](1)
  Assert g:vader_exception =~# 'WrongType'
endfor

Execute(writelines throws WrongType for iter that returns non-String);
AssertThrows call g:writable_fileobj.writelines(range(10))
Assert g:vader_exception =~# 'WrongType'

Execute(open an unwritable file throws IOError);
let t = MakeEmptyTempfile()
call MakeUnwritable(t)
AssertThrows call object#open(g:t, 'w')
Assert g:vader_exception =~# 'IOError'

Execute(Although open()'ed writable, f.write() and friends throw IOError if f becomes unwritable);
let t = MakeEmptyTempfile()
Assert filewritable(t)

let f = object#open(t, 'w')
call map(copy(write_family), 'f[v:val]("aaa")')

call MakeUnwritable(t)
for x in write_family
  AssertThrows call object#getattr(g:f, g:x)('aaa')
  Assert g:vader_exception =~# 'IOError'
endfor
