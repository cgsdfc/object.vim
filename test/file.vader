" vim:ft=vim
Before;
let lipsum = maktaba#path#Join([fnamemodify(g:vader_file, ':h'), 'data', 'lipsum.txt'])
let [mode_pattern, readable, writable, private_attrs] = object#file#patterns()
let f=object#open(lipsum)
let file_ = object#file_()
let bad_modes = [
      \ '+r', 'u', '@', ' r',
      \ "U+",
      \ ]
let read_family = ['read', 'readline', 'readlines']
let write_family = ['write', 'writeline', 'writelines']

" Helper to put some text in a tempfile.
"
function! MakeTempfile(list)
  if !exists('g:tempfile_list')
    let g:tempfile_list = []
  endif
  let t = tempname()
  call writefile(a:list, t)
  call add(g:tempfile_list, t)
  return t
endfunction

function! MakeEmptyTempfile()
  return MakeTempfile([])
endfunction

function! MakeUnreadable(f)
  call setfperm(a:f , "-w-r-----")
endfunction

After;
if exists('g:tempfile_list')
  call map(g:tempfile_list, 'delete(v:val)')
endif

"
" basic open()
"

Execute(open() without mode default for reading);
AssertEqual f.mode, 'r'
AssertEqual lipsum, f.name

"
" mode string
"

Execute(valid mode strings);
let valid_modes = [
      \ 'w', 'r', 'a',
      \ "w+", "r+", "a+",
      \ 'rw', 'ra', 'wa', 'wr', 'ar', 'aw',
      \ 'raw', 'rwa', 'awr', 'arw', 'war', 'wra',
      \ 'ra+', 'wr+', 'raw+',
      \ 'rkkk', 'r    +', 'www', 'w&&&+',
      \]
for x in valid_modes
  Assert x =~# mode_pattern
endfor

Execute(bad mode strings);
for x in bad_modes
  Assert x !~# mode_pattern
endfor

Execute(readable modes);
let positive = [ 'r', "w+", "a+", 'rw', 'ra',]
for x in positive
  Assert x =~# readable
endfor

Execute(not readable modes);
let negative = ['w', 'a', 'wa', 'aw' ]
for x in negative
  Assert x !~# readable
endfor

Execute(writable modes);
let positive = [ 'w', 'a', "r+", 'wa', 'wr',
      \ 'rw', 'r   +', 'www', "w+", "a+",
      \]
for x in positive
  Assert x =~# writable
endfor

Execute(not writable/readonly modes);
Assert 'r' !~# writable

"
" Hiding private attributes
"

Execute(pravite attrs not showing up);
for x in object#dir(f)
  Assert x !~# private_attrs
endfor

Execute(setattr() on file obj should throw AttributeError);
AssertThrows call object#setattr(g:f, 'x', 1)
Assert g:vader_exception =~# 'AttributeError.*no attribute'
for x in object#dir(f)
  AssertThrows call object#setattr(g:f, g:x, 1)
  Assert g:vader_exception =~# 'AttributeError.*readonly'
endfor

"
" Basic read* family.
"

Execute(read() returns all the lines);
let data = split(repeat('a', 10))
let t = MakeTempfile(data)
try
  let f = object#open(t)
  AssertEqual f.read(), join(data, "\n")
catch
  Log v:exception
  Log 'Test failed'
endtry

Execute(a second call to f.read() should return '');
call f.read()
AssertEqual '', f.read()

Execute(f.readline() should retrieve each line without tailing NL);
let data = map(range(10), 'string(v:val)')
let t = MakeTempfile(data)
try
  let f = object#open(t, 'r')
  for x in data
    AssertEqual x, f.readline()
  endfor
  AssertEqual f.readline(), ''
catch
  Log v:exception
endtry

Execute(f.readlines() returns a list of all lines in f, which is equal to readfile());
AssertEqual f.readlines(), readfile(lipsum)
AssertEqual f.readlines(), []

"
" read*() throwing IOError
"

Execute(open()'ing an unreadable file throws IOError);
" chmod -r lipsum.txt
let t = MakeEmptyTempfile()
Assert maktaba#path#Exists(t)
try
  call MakeUnreadable(t)
  AssertThrows call object#open(g:t, 'r')
catch
  throw v:exception
endtry
Assert g:vader_exception =~# 'IOError'

Execute(Although open()'ed readable, f.read() and friends throw IOError if f becomes unreadable);
let t = MakeEmptyTempfile()
Assert filereadable(t)

let f = object#open(t)
call map(copy(read_family), 'f[v:val]()')

call MakeUnreadable(t)
for x in read_family
  AssertThrows call g:f[g:x]()
  Assert g:vader_exception =~# 'IOError'
endfor

Execute(open() throws ValueError for bad mode string);
for x in bad_modes
  AssertThrows call object#open(MakeEmptyTempfile(), x)
  Assert g:vader_exception =~# 'ValueError'
endfor

