" vim:ft=vim
" Test Exceptions
Before;
function! UserDefinedError(...)
  return object#BaseException('UserDefinedError', a:000)
endfunction
let builtin_exceptions = [
      \ 'Exception',
      \ 'ValueError',
      \ 'TypeError',
      \ 'AttributeError',
      \ 'IOError',
      \ 'IndexError',
      \ 'KeyError',
      \ ]


" Signature of the created exceptions.
Execute(No args);
Assert UserDefinedError() =~# 'UserDefinedError:'

Execute(One single msg);
Assert UserDefinedError('message') =~# 'UserDefinedError: message'

Execute(printf-style args);
let err = UserDefinedError('number %d, string %s, char %c', 4, 'a', 44)
Assert err =~# '^UserDefinedError:.*4.*a.*,'

Execute(Create exceptions that takes no arguments);
function! TakeNoArgs()
  return object#BaseException('TakeNoArgs')
endfunction
Assert TakeNoArgs() =~# 'TakeNoArgs:'


" Built-in exceptions
Execute(Built-in exceptions works fine);
for x in builtin_exceptions
  let code = printf('object#%s()', x)
  Assert eval(code) =~# printf('%s:', x)
endfor

" Sanity checks.
Execute(Throws WrongType if args[0] is not String);
AssertThrows call object#BaseException('Error', [1])
Assert g:vader_exception =~# 'WrongType'


Execute(Throw ValueError if type is not an identifier);
let input = [
      \ '999',
      \ ' ValueError',
      \ 'ValueError ',
      \ ' ValueError ',
      \ '^_^',
      \ '$Exception',
      \ ]

for x in input
  AssertThrows call object#BaseException(g:x)
  Assert g:vader_exception =~# 'ValueError'
endfor

Execute(StopIteration() is simply itself);
AssertEqual object#StopIteration(), 'StopIteration:'

Execute(not_avail() throws TypeError);
AssertThrows throw object#except#not_avail('len', 1)
Log g:vader_exception
Assert g:vader_exception =~# 'TypeError'
