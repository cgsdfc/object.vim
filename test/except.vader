" vim:ft=vim

Execute(BaseException() should allow to create new exceptions);
function! UserDefinedError(msg, ...)
  return object#BaseException('UserDefinedError', a:msg, a:000)
endfunction

let err = UserDefinedError('some errors (%d)', 4)
Assert err =~# '^UserDefinedError: some errors (4)$'

Assert UserDefinedError('message') =~# '^UserDefinedError: message$'
try
  throw UserDefinedError('ops')
catch/UserDefinedError/
  Assert v:exception =~# 'ops'
endtry

Execute(Built-in exceptions works fine);
let exceptions = [ 'Exception', 'ValueError', 'TypeError', 'AttributeError',
      \ 'IOError'
      \ ]
for x in exceptions
  AssertThrows throw object#{g:x}('error (%d)', 1)
  Assert g:vader_exception =~# printf('%s: error (1)', x)
endfor

Execute(BaseException() should throw WrongType if any of its arguments have wrong type);
let input = [
      \ [ 1, '', []],
      \ [ 'foo', 1, []],
      \ [ 'foo', '', 1],
      \ [ 1, 1, 1],
      \ ]

for [type, msg, args] in input
    AssertThrows call object#BaseException(g:type, g:msg, g:args)
    Assert g:vader_exception =~# 'ERROR(WrongType)'
endfor

Execute(BaseException() should throw ValueError if the type argument failed to match a pattern);
let input = [
      \ '999',
      \ ' ValueError',
      \ 'ValueError ',
      \ ' ValueError ',
      \ '^_^',
      \ '$Exception',
      \ ]

for x in input
  try
    call object#BaseException(x, '', [])
  catch/ValueError/
    Assert v:exception =~# 'identifier'
  endtry
endfor

Execute(StopIteration() is simply itself);
AssertEqual object#StopIteration(), 'StopIteration:'

Execute(not_avail() throws TypeError);
AssertThrows throw object#except#not_avail('len', 1)
Log g:vader_exception
Assert g:vader_exception =~# 'TypeError'
