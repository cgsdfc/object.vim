*object.vim.txt*
                                                         *object* *object.vim*

==============================================================================
CONTENTS                                                 *object.vim-contents*
  1. Introduction...........................................|object.vim-intro|
  2. Protocols..........................................|object.vim-protocols|
  3. Class..................................................|object.vim-class|
  4. Mapping..............................................|object.vim-mapping|
  5. Iterator................................................|object.vim-iter|
  6. File....................................................|object.vim-file|
  7. Types..................................................|object.vim-types|
  8. Dictionaries...........................................|object.vim-dicts|
  9. Functions..........................................|object.vim-functions|
  10. Exceptions.......................................|object.vim-exceptions|

==============================================================================
INTRODUCTION                                                *object.vim-intro*

A vimscript library that provides object protocols for Vim similar to Python.


==============================================================================
PROTOCOLS                                               *object.vim-protocols*

A set of basic hookable functions that inspect and operate on different
properties of an object. A protocol in this context means an global function
that has well defined behaviours for built-in types and can be overriden by
the corresponding methods with double underscores names.

==============================================================================
CLASS                                                       *object.vim-class*

functions for creating both classes and instances and testing their
relationships. Inheritance is possible. The methods of base classes are added
from left to right across the [bases] when class() is called. The methods
defined for this class effectively override those from bases.


Features:
  * Multiple inheritance.
  * Calling methods from supers.
  * Type identification.

Drawbacks:
  * Use more space for the house keeping attributes.
  * Takes more time for the class and instance creation.

Limitations:
  * Methods are resolved statically at class creation time, which makes the
    class object even larger.

==============================================================================
MAPPING                                                   *object.vim-mapping*

An interface to key-value containers. A mapping is an object that supports
accessing its values through a set of keys or in short, the subscription
operator. The built-in |String|, |Dict| and |List| can all be viewed as
mapping. This idea is generalized by the functions provided.

Features:
  * Hookable hash() works for built-in types.
  * Hookable getitem() and setitem() functions works built in types.

==============================================================================
ITERATOR                                                     *object.vim-iter*

Iterator protocol.

Features:
  * Vim-compatible map() and filter() that works with iterators.
  * dict() creates |Dict| from an iterator and a lambda, which is similar to
    dict comprehension.
  * filter() evaluates lambda using |object#types#bool()|.
  * Provide iterators for |String| and |List| that works transparently.
  * Helpers like sum(), all(), any(), zip() and enumerate() all work as
    expected.

Limitations:
  * No intuitive |for| syntax for looping over iterators.
  * The powerful generator and yield() in Python are not supported.

Examples:
>
  :echo object#all(range(10))
  0

  :echo object#list(object#enumerate('abc'))
  [[0, 'a'], [1, 'b'], [2,'c']]

  :echo object#dict('abc', '[toupper(v:val), v:val]')
  {'A': 'a', 'B': 'b', 'C': 'c'}

  :echo object#dict(object#enumerate('abc'), '[v:val[1], v:val[0]]')
  {'a': 0, 'b': 1, 'c': 2}

  :echo object#dict(object#zip('abc', range(3)))
  {'a': 0, 'b': 1, 'c': 2}

  :echo object#sum(range(1, 100))
  5050

  :echo object#filter(['1', '2', ''], 'v:val')
  ['1', '2']
<

==============================================================================
FILE                                                         *object.vim-file*

A simple interface to the |readfile()| and |writefile()| functions.

Features:
  * Lazy reading and writing.
  * Line-oriented I/O.
  * Handle errors with IOError.
  * Mode string syntax like 'a', 'w' or '+', 'b'.

Limitations:
  * The file is always buffered.
  * The content of the file object is not synchronized with external changes
    to the underlying file.
  * The file is unseekable. All reading or writing happens essentially at the
    current line number.
  * No context manager available. Must call f.close() explicitly or you may
    lost written data.

Note:
  * Unlike the counterparts from Python, readlines() always strips tailing
    newlines and
  * writelines() always adds tailing newlines.

Examples:
>
  Your file is
  1
  2
  3
  :echo f.readlines()
  ['1', '2', '3']

  :call f.writelines(range(3))
  :call f.close()
  Your file becomes
  1
  2
  3
<
This is rooted at the nature of |readfile()| and |writefile()|.

==============================================================================
TYPES                                                       *object.vim-types*

Define a minimal set of fundamental types as the basic of the type hierarchy.
They are:
  * object(None): The base class of all the rest of classes. The base class of
    it is None, the only instance of the NoneType.

  * type(object): The class of all the types for both built-in and user
    definded ones. In other words, every class is an instance of type.

  * NoneType(type): The class of the None object, the place holder for absence
    of sensible values, such as the base class of object.

==============================================================================
DICTIONARIES                                                *object.vim-dicts*

                                                             *object.vim.file*

file.read()                                                      *file.read()*
  Read the the whole of the file, return it as a string. Lines are joint with
  a NL character.

file.readline()                                              *file.readline()*
  Return the next line from the file. Return an empty string at EOF.

  Note: Newlines are stripped.

file.readlines()                                            *file.readlines()*
  Return a list of strings, each a line from the file.

  Note: Newlines are stripped.

file.write({str})                                               *file.write()*
  Write a {str} to the file. {str} is appended to the last line of file.

  Note: If {str} becomes the first line of the file, a newline will be added
  right after this line as if it is done with writeline().

file.writeline({line})                                      *file.writeline()*
  Write a {line} to the file.

file.writelines({iter})                                    *file.writelines()*
  Write a sequence of strings to the file.
  Throws ERROR(WrongType) if {iter} returns non-string.

file.flush()                                                    *file.flush()*
  Flush the written data.
  Throws ERROR(IOError) if |writefile()| fails.

file.close()                                                    *file.close()*
  Close the file and flush it. After that any file operation will fail.
  Calling close() multiple times does not causes errors.

file.readable()                                              *file.readable()*
  Return whether the file is opened for reading.

file.writable()                                              *file.writable()*
  Return whether the file is opened for writing.

file.__bool__()                                              *file.__bool__()*
  __bool__(file) <==> file is not closed.

file.__iter__()                                              *file.__iter__()*
  __iter__(file) <==> each line of file.

file.__init__({name}, {mode})                                *file.__init__()*
  Initialize a file object with {name} and {mode}.
  Throws ERROR(WrongType) if {mode} is not a String.
  Throws ERROR(ValueError) is {mode} string is invalid.
  Throws ERROR(IOError) if the file is not readable or writable.

file.__repr__()                                              *file.__repr__()*
  __repr__(file) <==> repr(file)

==============================================================================
FUNCTIONS                                               *object.vim-functions*

object#class#class({name}, [bases])                     *object#class#class()*
  Define a class that has a {name} and optional base class(es). {name} should
  be a |String| of valid identifier in Vim. [bases] should be a class object
  or a |List| of class objects. If no [bases] are given or [bases] is an empty
  |List|, the new class will subclass object. Return the newly created class
  with only inherited attributes.

object#class#new({cls}, [args])                           *object#class#new()*
  Create a new instance. This is done by first creating a skeleton object from
  the attributes of the {cls} and then calling __init__ of the newly created
  object with [args].

object#class#type()                                      *object#class#type()*
  type(obj) -> class of obj.

  type(name, bases, dict) -> a new type.

object#class#super({cls}, {obj}, {method})              *object#class#super()*
  Return a method from the direct base {cls} of {obj}. This is done by binding
  the methods of {cls} to {obj}.

  Throws ERROR(TypeError) if {cls} is not a direct base of {obj}.

object#class#isinstance({obj}, {cls})              *object#class#isinstance()*
  Return whether {obj} is an instance of {cls}.

object#class#issubclass({cls}, {base})             *object#class#issubclass()*
  Return wheter {cls} is a subclass of {base}.

object#except#BaseException({type}, {msg}, {args})
                                               *object#except#BaseException()*
  Generate exception for a specific {type}. User can call BaseException to
  define their own exception functions. Examples:
>
    function! MyException(msg, ...)
      return object#BaseException('MyException', a:msg, a:000)
    endfunction
<

object#file#open({name}, [mode])                          *object#file#open()*
  Open a file. The [mode] can be 'r', 'w' or 'a' for reading (default),
  writing or appending. The file will be created if it doesn't exist when
  opened for writing or appending; it will be truncated when opened for
  writing. Add a 'b' to the [mode] for binary files. Add a '+' to the [mode]
  to allow simultaneous reading and writing.

object#iter#iter({obj})                                   *object#iter#iter()*
  Return an iterator from {obj}. If {obj} is already an iterator, it is
  returned as it. Built-in |List| and |String| have iterators. An __iter__
  method of {obj} that returns an iterator will be used if possible.

  Throws ERROR(WrongType) if {obj} has an unusable __next__.
  Throws ERROR(TypeError) if the __iter__ of {obj} does not return an
  iterator.

object#iter#next({obj})                                   *object#iter#next()*
  Retrieve the next item from the iterator {obj}.

object#iter#any({iter})                                    *object#iter#any()*
  Return true iff any item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#all({iter})                                    *object#iter#all()*
  Return true iff all item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#dict([iter])                                  *object#iter#dict()*

>
    dict() -> an empty dictionary.
    dict(iterable) -> initiazed with 2-list items.
    dict(iterable, lambda) -> applies lambda to iterable, initiazed with the
      resulting list.
    dict(plain dictionary) -> a copy of the argument.
<

  Turn an iterator that returns 2-list into a |Dict|. If no [iter] is given,
  an empty |Dict| is returned. If a |Dict| is given, it is effectively
  |copy()|'ed.

object#iter#list([iter])                                  *object#iter#list()*

>
    list() -> an empty list.
    list(iterable) -> initiazed with items of iterable.
<

  Turn an iterator into a |List|. If no [iter] is given, an empty |List| is
  returned. If a |List| is given, it is effectively |copy()|'ed.

object#iter#enumerate({iter}, [start])               *object#iter#enumerate()*
  Return an iterator for index, value of {iter} Take an optional [start].

object#iter#zip({iter}, [iters])                           *object#iter#zip()*
  Return an iterator that returns [seq1[i], seq[i], ...] for the ith call of
  object#next(). The iterator stops when the first StopIteration is raised by
  one of the [iters].

object#iter#map({iter}, {lambda})                          *object#iter#map()*
  Create a new list by applying {lambda} to each item of an {iter}. {lambda}
  should be a |String| that is acceptable by built-in |map()|.

object#iter#filter({iter}, {lambda})                    *object#iter#filter()*
  Create a new list by removing the item from {iter} when {lambda} return
  false. Truthness is evaluated by object#bool(). {lambda} should be a
  |String| that is acceptable by built-in |filter()|.

object#iter#sum({iter}, [start])                           *object#iter#sum()*
  Return the sum of items from {iter} plus the value of parameter [start],
  which defaults to 0. Items must be either |Number|s or |Float|s, i.e.,
  numeric. If {iter} is empty, [start] is returned.

  Throws ERROR(WrongType) if any item is not numeric.

object#mapping#hash({obj})                             *object#mapping#hash()*
  Return the hash value of {obj}. {obj} can be a |Number|, a |String| a
  |Funcref| or special variables like |v:none| and |v:false|, or an object
  with __hash__() defined.

  Throws ERROR(TypeError) if hash() is not possible for {obj}.
  Throws ERROR(WrongType) if __hash__ is not a |Funcref| or returns
  something NAN (Not A Number).

object#mapping#getitem({obj}, {key})                *object#mapping#getitem()*
  Return the value at {key} in {obj} as if {obj} is a mapping. If {obj} is a
  |List|, |String| or plain |Dict|, checked-version of built-in subscription
  will be called. Vim error about |List| index will translate to
  @exception(IndexError). Vim's ignorance about the index to |String| will be
  augmented by checking the emptiness of the value.

  Throws ERROR(WrongType) if {obj} is a |String| or |List| but {key} is not a
  |Number| or {obj} is a |Dict| but {key} is not a |String|.

  Throws ERROR(IndexError) if {key} is out of range for |String| or |List|.
  Throws ERROR(KeyError) if {key} is not present in the |Dict|.

object#mapping#setitem({obj}, {key}, {val})         *object#mapping#setitem()*
  Set the value at {key} of {obj} to {val}. If {obj} is a |List|, |String| or
  a |Dict|, subscription version of |let| will be uesd. Otherwise, __setitem__
  of {obj} will be used.

object#protocols#getattr({obj}, {name})           *object#protocols#getattr()*
  Get the attribute {name} from {obj}. Note: The __getattr__() hook overrides
  the dictionary lookup completely. That means it is not consulted after
  dictionary lookup failed but used directly if there is a usable one.


object#protocols#setattr({obj}, {name}, {val})    *object#protocols#setattr()*
  Set the {name} attribute of {obj} to {val}.


object#protocols#hasattr({obj}, {name})           *object#protocols#hasattr()*
  Test whether {obj} has attribute {name}. Return false if {obj} is not a
  |Dict|.


object#protocols#repr({obj})                         *object#protocols#repr()*
  Generate string representation for {obj}. Fail back on |string()|


object#protocols#len({obj})                           *object#protocols#len()*
  Return the length of {obj}. If {obj} is a |List| or a |Dict|, |len()| will
  be called. Otherwise, the __len__() of {obj} will be called.


object#protocols#dir({obj})                           *object#protocols#dir()*
  Return a |List| of names of all attributes from {obj}. If {obj} defines
  __dir__(), it is called instead.


object#types#object()                                  *object#types#object()*
  Create a plain object.

object#types#object_()                                *object#types#object_()*
  Return the object class

object#types#type_()                                    *object#types#type_()*
  Return the type class

object#types#NoneType()                              *object#types#NoneType()*
  Return the NoneType class

object#types#None()                                      *object#types#None()*
  Return the None object

==============================================================================
EXCEPTIONS                                             *object.vim-exceptions*

                                                            *ERROR(Exception)*
Generic exception.

                                                           *ERROR(ValueError)*
The value of function arguments went wrong.

                                                            *ERROR(TypeError)*
Unsupported operation for a type or wrong number of arguments passed to a
function.

                                                       *ERROR(AttributeError)*
The object has no such attribute or the attribute is readonly.

                                                        *ERROR(StopIteration)*
The end of iteration. Thrown by __iter__ usually.

                                                           *ERROR(IndexError)*
Index out of range for sequences.

                                                             *ERROR(KeyError)*
Key out of range for sequences.

                                                              *ERROR(IOError)*
File not writable or readable. Operation on a closed file. Thrown by file
objects usually.


vim:tw=78:ts=8:ft=help:norl:
