*object.vim.txt*
                                                         *object* *object.vim*

==============================================================================
CONTENTS                                                 *object.vim-contents*
  1. Introduction...........................................|object.vim-intro|
  2. Dictionaries...........................................|object.vim-dicts|
  3. Functions..........................................|object.vim-functions|
  4. Exceptions........................................|object.vim-exceptions|

==============================================================================
INTRODUCTION                                                *object.vim-intro*

A vimscript library that provides object protocols for Vim similar to Python.


==============================================================================
DICTIONARIES                                                *object.vim-dicts*

                                                             *object.vim.file*
A simple interface to the |readfile()| and |writefile()| functions.

Features:
  * Lazy reading and writing.
  * Line-oriented reading and writing.
  * Mode string syntax like 'a', 'w' or '+', 'b'.

Limitations:
  * The file cannot be unbuffered.
  * The file is unseekable. All reading or writing happens essentially at the
    current line number.
  * No context manager. Must call f.close() explicitly.


file.read()                                                      *file.read()*
  Read the the whole of the file, return it as a string. Lines are joint with
  a NL character.


file.readline()                                              *file.readline()*
  Return the next line from the file. Return an empty string at EOF. Note:
  Newlines are not retained.


file.readlines()                                            *file.readlines()*
  Return a list of strings, each a line from the file. Note: Newlines are not
  retained.


file.write({str})                                               *file.write()*
  Write a {str} to the file. {str} is appended to the last line of file.


file.writeline({line})                                      *file.writeline()*
  Write a {line} to the file.


file.writelines({iter})                                    *file.writelines()*
  Write a sequence of strings to the file.
  Throws ERROR(WrongType) if {iter} returns non-string.


file.flush()                                                    *file.flush()*
  Flush the written data.
  Throws ERROR(IOError) if |writefile()| fails.


file.close()                                                    *file.close()*
  Close the file and flush it. Any file operation fails after it is closed.
  Calling close() for multiple times does not causes an error.


file.__setattr__({name}, {val})                           *file.__setattr__()*
  We cannot stop people doing let file.closed = 1, but with object#setattr(),
  stupid things can be prevented.
  Throws ERROR(AttributeError) if anyone attempts to setattr for a file
  object.


file.__dir__()                                                *file.__dir__()*
  Hide the private attributes from dir()


file.__getattr__({name})                                  *file.__getattr__()*
  Hide the private attributes from getattr().


file.__bool__()                                              *file.__bool__()*
  __bool__(file) <==> file is not closed.


file.__iter__()                                              *file.__iter__()*
  __iter__(file) <==> each line of file.


file.__init__({name}, {mode})                                *file.__init__()*
  Initialize a file object with {name} and {mode}.
  Throws ERROR(WrongType) if {mode} is not a String.
  Throws ERROR(ValueError) is {mode} string is invalid.
  Throws ERROR(IOError) if the file is not readable or writable.


file.__repr__()                                              *file.__repr__()*
  __repr__(file) <==> filename and mode.


==============================================================================
FUNCTIONS                                               *object.vim-functions*

object#class#class({name}, [bases])                     *object#class#class()*
  Define a class that has a name and optional base class(es).
>
    let Widget = object#class('Widget')
    let Widget = object#class('Widget', [...])
<
  [bases] should be a |Dict| or a |List| of |Dict| that was defined by
  class(). If no [bases] are given or empty(bases), the new class will
  subclass object. {name} should be a |String| of valid identifier in Vim. The
  return value is special |Dict| to which methods can be added to and from
  which instance can be created by new(). Methods can be added by:
>
    function! Widget.say_yes()
      ...
    endfunction
<
  or
>
    let Widget.say_yes = function('widget#say_yes')
<

  Inheritance is possible. The methods of base classes are added from left to
  right across the [bases] when class() is called. The methods defined for
  this class effectively override those from bases.


object#class#new({cls}, [args])                           *object#class#new()*
  Create a new instance of {cls} by applying optional [args].


object#class#type()                                      *object#class#type()*
  type(obj) -> class of obj. type(name, bases, dict) -> a new type.


object#class#super({cls}, {obj}, {method})              *object#class#super()*
  Return a partial |Funcref| that binds the dict of {method} of the base class
  {cls} of {obj} to {obj} Examples:
>
    call object#super(Base, self, '__init__')(...)
<


object#class#isinstance({obj}, {cls})              *object#class#isinstance()*
  Return whether {obj} is an instance of {cls}.


object#class#issubclass({cls}, {base})             *object#class#issubclass()*
  Return wheter {cls} is a subclass of {base}.


object#file#open({mode})                                  *object#file#open()*
  Open a file. The {mode} can be 'r', 'w' or 'a' for reading (default),
  writing or appending. The file will be created if it doesn't exist when
  opened for writing or appending; it will be truncated when opened for
  writing. Add a 'b' to the {mode} for binary files. Add a '+' to the {mode}
  to allow simultaneous reading and writing.


object#file#file_()                                      *object#file#file_()*
  Return the file class object.


object#iter#iter({obj})                                   *object#iter#iter()*
  Return an iterator from {obj}.


object#iter#next({obj})                                   *object#iter#next()*
  Retrieve the next item from the iterator {obj}.


object#iter#enumerate({iter}, [start])               *object#iter#enumerate()*
  iterator for index, value of iterable. Take an optional [start].


object#mapping#hash({obj})                             *object#mapping#hash()*
  Return the hash value of {obj}. {obj} can be a |Number|, a |String| or
  special variables like |v:none| and |v:false|, or an object with __hash__()
  defined.

  Throws ERROR(TypeError) if {obj} is a |List|, |Float| or |Dict|.
  Throws ERROR(WrongType) if __hash__ is not a |Funcref| or returns
  something NAN (Not A Number).


object#mapping#getitem({obj}, {key})                *object#mapping#getitem()*
  Return the value at {key} in {obj} as if {obj} is a mapping. If {obj} is a
  |List| or |Dict|, operator[] of Vim will be used.

object#mapping#setitem({obj}, {key}, {val})         *object#mapping#setitem()*
  Set the value at {key} of {obj} to {val}. If {obj} is a |List| or a |Dict|
  without __setitem__(), |let| will be uesd. Otherwise, __setitem__() of {obj}
  will be used.


object#protocols#getattr({obj}, {name})           *object#protocols#getattr()*
  Get the attribute {name} from {obj}. Note: The __getattr__() hook overrides
  the dictionary lookup completely. That means it is not consulted after
  dictionary lookup failed but used directly if there is a usable one.


object#protocols#setattr({obj}, {name}, {val})    *object#protocols#setattr()*
  Set the {name} attribute of {obj} to {val}.


object#protocols#hasattr({obj}, {name})           *object#protocols#hasattr()*
  Test whether {obj} has attribute {name}. Return false if {obj} is not a
  |Dict|.


object#protocols#repr({obj})                         *object#protocols#repr()*
  Generate string representation for {obj}. Fail back on |string()|


object#protocols#len({obj})                           *object#protocols#len()*
  Return the length of {obj}. If {obj} is a |List| or a |Dict|, |len()| will
  be called. Otherwise, the __len__() of {obj} will be called.


object#protocols#dir({obj})                           *object#protocols#dir()*
  Return a |List| of names of all attributes from {obj}. If {obj} defines
  __dir__(), it is called instead.


object#types#object()                                  *object#types#object()*
  Create a plain object.

object#types#object_()                                *object#types#object_()*
  Return the object class

object#types#type_()                                    *object#types#type_()*
  Return the type class

object#types#NoneType()                              *object#types#NoneType()*
  Return the NoneType class

object#types#None()                                      *object#types#None()*
  Return the None object

==============================================================================
EXCEPTIONS                                             *object.vim-exceptions*

                                                            *ERROR(Exception)*

                                                           *ERROR(ValueError)*

                                                            *ERROR(TypeError)*

                                                       *ERROR(AttributeError)*

                                                        *ERROR(StopIteration)*

                                                              *ERROR(IOError)*


vim:tw=78:ts=8:ft=help:norl:
