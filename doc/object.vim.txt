*object.vim.txt*
                                                         *object* *object.vim*

==============================================================================
CONTENTS                                                 *object.vim-contents*
  1. Introduction...........................................|object.vim-intro|
  2. Mapping..............................................|object.vim-mapping|
  3. Iterator................................................|object.vim-iter|
  4. file....................................................|object.vim-file|
  5. Dictionaries...........................................|object.vim-dicts|
  6. Functions..........................................|object.vim-functions|
  7. Exceptions........................................|object.vim-exceptions|

==============================================================================
INTRODUCTION                                                *object.vim-intro*

A vimscript library that provides object protocols for Vim similar to Python.


==============================================================================
MAPPING                                                   *object.vim-mapping*

An interface to key-value containers. A mapping is an object that supports
accessing its values through a set of keys or in short, the subscription
operator. The built-in |String|, |Dict| and |List| can all be viewed as
mapping. This idea is generalized by the functions provided.

Features:
  * Hookable hash() works for built-in types.
  * Hookable getitem() and setitem() functions works built in types.

==============================================================================
ITERATOR                                                     *object.vim-iter*

Iterator protocol. Provide functions that produce and manipulate iterators and
iterators for built-in types like |List| and |String|.

Features:

==============================================================================
FILE                                                         *object.vim-file*

A simple interface to the |readfile()| and |writefile()| functions.

Features:
  * Lazy reading and writing.
  * Line-oriented I/O.
  * Handle errors with IOError.
  * Mode string syntax like 'a', 'w' or '+', 'b'.

Limitations:
  * The file is always buffered.
  * The content of the file object is not synchronized with external changes
    to the underlying file.
  * The file is unseekable. All reading or writing happens essentially at the
    current line number.
  * No context manager available. Must call f.close() explicitly or you may
    lost written data.

Note:
  * Unlike the counterparts from Python, readlines() always strips tailing
    newlines and
  * writelines() always adds tailing newlines.

Examples:
>
  Your file is
  1
  2
  3
  :echo f.readlines()
  ['1', '2', '3']

  :call f.writelines(range(3))
  :call f.close()
  Your file becomes
  1
  2
  3
<
This is rooted at the nature of |readfile()| and |writefile()|.

==============================================================================
DICTIONARIES                                                *object.vim-dicts*

                                                             *object.vim.file*

file.read()                                                      *file.read()*
  Read the the whole of the file, return it as a string. Lines are joint with
  a NL character.

file.readline()                                              *file.readline()*
  Return the next line from the file. Return an empty string at EOF.

  Note: Newlines are stripped.

file.readlines()                                            *file.readlines()*
  Return a list of strings, each a line from the file.

  Note: Newlines are stripped.

file.write({str})                                               *file.write()*
  Write a {str} to the file. {str} is appended to the last line of file.

  Note: If {str} becomes the first line of the file, a newline will be added
  right after this line as if it is done with writeline().

file.writeline({line})                                      *file.writeline()*
  Write a {line} to the file.

file.writelines({iter})                                    *file.writelines()*
  Write a sequence of strings to the file.
  Throws ERROR(WrongType) if {iter} returns non-string.

file.flush()                                                    *file.flush()*
  Flush the written data.
  Throws ERROR(IOError) if |writefile()| fails.

file.close()                                                    *file.close()*
  Close the file and flush it. After that any file operation will fail.
  Calling close() multiple times does not causes errors.

file.__setattr__({name}, {val})                           *file.__setattr__()*
  Throws ERROR(AttributeError) if anyone attempts to setattr for a file
  object.

file.__dir__()                                                *file.__dir__()*
  Return names of attributes.

file.__getattr__({name})                                  *file.__getattr__()*
  Return the attribute {name}.

file.__bool__()                                              *file.__bool__()*
  __bool__(file) <==> file is not closed.

file.__iter__()                                              *file.__iter__()*
  __iter__(file) <==> each line of file.

file.__init__({name}, {mode})                                *file.__init__()*
  Initialize a file object with {name} and {mode}.
  Throws ERROR(WrongType) if {mode} is not a String.
  Throws ERROR(ValueError) is {mode} string is invalid.
  Throws ERROR(IOError) if the file is not readable or writable.

file.__repr__()                                              *file.__repr__()*
  __repr__(file) <==> repr(file)

==============================================================================
FUNCTIONS                                               *object.vim-functions*

object#class#class({name}, [bases])                     *object#class#class()*
  Define a class that has a name and optional base class(es).
>
    let Widget = object#class('Widget')
    let Widget = object#class('Widget', [...])
<
  [bases] should be a |Dict| or a |List| of |Dict| that was defined by
  class(). If no [bases] are given or empty(bases), the new class will
  subclass object. {name} should be a |String| of valid identifier in Vim. The
  return value is special |Dict| to which methods can be added to and from
  which instance can be created by new(). Methods can be added by:
>
    function! Widget.say_yes()
      ...
    endfunction
<
  or
>
    let Widget.say_yes = function('widget#say_yes')
<

  Inheritance is possible. The methods of base classes are added from left to
  right across the [bases] when class() is called. The methods defined for
  this class effectively override those from bases.


object#class#new({cls}, [args])                           *object#class#new()*
  Create a new instance of {cls} by applying optional [args].


object#class#type()                                      *object#class#type()*
  type(obj) -> class of obj. type(name, bases, dict) -> a new type.


object#class#super({cls}, {obj}, {method})              *object#class#super()*
  Return a partial |Funcref| that binds the dict of {method} of the base class
  {cls} of {obj} to {obj} Examples:
>
    call object#super(Base, self, '__init__')(...)
<


object#class#isinstance({obj}, {cls})              *object#class#isinstance()*
  Return whether {obj} is an instance of {cls}.


object#class#issubclass({cls}, {base})             *object#class#issubclass()*
  Return wheter {cls} is a subclass of {base}.


object#file#open({name}, [mode])                          *object#file#open()*
  Open a file. The [mode] can be 'r', 'w' or 'a' for reading (default),
  writing or appending. The file will be created if it doesn't exist when
  opened for writing or appending; it will be truncated when opened for
  writing. Add a 'b' to the [mode] for binary files. Add a '+' to the [mode]
  to allow simultaneous reading and writing.

object#iter#iter({obj})                                   *object#iter#iter()*
  Return an iterator from {obj}. If {obj} is already an iterator, it is
  returned as it. Built-in |List| and |String| have iterators. An __iter__
  method of {obj} that returns an iterator will be used if possible.

  Throws ERROR(WrongType) if {obj} has an unusable __next__.
  Throws ERROR(TypeError) if the __iter__ of {obj} does not return an
  iterator.

object#iter#next({obj})                                   *object#iter#next()*
  Retrieve the next item from the iterator {obj}.

object#iter#any({iter})                                    *object#iter#any()*
  Return true iff any item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#all({iter})                                    *object#iter#all()*
  Return true iff all item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#dict([iter])                                  *object#iter#dict()*
  Turn an iterator that returns 2-list into a |Dict|. If no [iter] is given,
  an empty |Dict| is returned.

object#iter#list([iter])                                  *object#iter#list()*
  Turn an iterator into a |List|. If no [iter] is given, an empty |List| is
  returned.

object#iter#enumerate({iter}, [start])               *object#iter#enumerate()*
  Return an iterator for index, value of {iter} Take an optional [start].

object#iter#zip({iter}, [iters])                           *object#iter#zip()*
  Return an iterator that returns [seq1[i], seq[i], ...] for the ith call of
  object#next(). The iterator stops when the first StopIteration is raised by
  one of the [iters].

object#mapping#hash({obj})                             *object#mapping#hash()*
  Return the hash value of {obj}. {obj} can be a |Number|, a |String| a
  |Funcref| or special variables like |v:none| and |v:false|, or an object
  with __hash__() defined.

  Throws ERROR(TypeError) if hash() is not possible for {obj}.
  Throws ERROR(WrongType) if __hash__ is not a |Funcref| or returns
  something NAN (Not A Number).

object#mapping#getitem({obj}, {key})                *object#mapping#getitem()*
  Return the value at {key} in {obj} as if {obj} is a mapping. If {obj} is a
  |List|, |String| or |Dict|, built-in subscription will be used.

object#mapping#setitem({obj}, {key}, {val})         *object#mapping#setitem()*
  Set the value at {key} of {obj} to {val}. If {obj} is a |List|, |String| or
  a |Dict|, subscription version of |let| will be uesd. Otherwise, __setitem__
  of {obj} will be used.

object#protocols#getattr({obj}, {name})           *object#protocols#getattr()*
  Get the attribute {name} from {obj}. Note: The __getattr__() hook overrides
  the dictionary lookup completely. That means it is not consulted after
  dictionary lookup failed but used directly if there is a usable one.


object#protocols#setattr({obj}, {name}, {val})    *object#protocols#setattr()*
  Set the {name} attribute of {obj} to {val}.


object#protocols#hasattr({obj}, {name})           *object#protocols#hasattr()*
  Test whether {obj} has attribute {name}. Return false if {obj} is not a
  |Dict|.


object#protocols#repr({obj})                         *object#protocols#repr()*
  Generate string representation for {obj}. Fail back on |string()|


object#protocols#len({obj})                           *object#protocols#len()*
  Return the length of {obj}. If {obj} is a |List| or a |Dict|, |len()| will
  be called. Otherwise, the __len__() of {obj} will be called.


object#protocols#dir({obj})                           *object#protocols#dir()*
  Return a |List| of names of all attributes from {obj}. If {obj} defines
  __dir__(), it is called instead.


object#types#object()                                  *object#types#object()*
  Create a plain object.

object#types#object_()                                *object#types#object_()*
  Return the object class

object#types#type_()                                    *object#types#type_()*
  Return the type class

object#types#NoneType()                              *object#types#NoneType()*
  Return the NoneType class

object#types#None()                                      *object#types#None()*
  Return the None object

==============================================================================
EXCEPTIONS                                             *object.vim-exceptions*

                                                            *ERROR(Exception)*

                                                           *ERROR(ValueError)*

                                                            *ERROR(TypeError)*

                                                       *ERROR(AttributeError)*

                                                        *ERROR(StopIteration)*

                                                              *ERROR(IOError)*


vim:tw=78:ts=8:ft=help:norl:
