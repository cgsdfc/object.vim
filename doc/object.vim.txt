*object.vim.txt*	An Object-Oriented Framework for Vimscript
cgsdfc                                                   *object* *object.vim*

==============================================================================
CONTENTS                                                 *object.vim-contents*
  1. Introduction...........................................|object.vim-intro|
  2. Protocols..........................................|object.vim-protocols|
  3. Class..................................................|object.vim-class|
  4. Mapping..............................................|object.vim-mapping|
  5. Iterator................................................|object.vim-iter|
  6. File....................................................|object.vim-file|
  7. Types..................................................|object.vim-types|
  8. Lambda................................................|object.vim-lambda|
  9. Dictionaries...........................................|object.vim-dicts|
  10. Functions.........................................|object.vim-functions|
  11. Exceptions.......................................|object.vim-exceptions|
  12. Motivation.......................................|object.vim-motivation|

==============================================================================
INTRODUCTION                                                *object.vim-intro*


>
                             __      _           __
                      ____  / /_    (_)__  _____/ /_
                     / __ \/ __ \  / / _ \/ ___/ __/
                    / /_/ / /_/ / / /  __/ /__/ /_
                    \____/_.___/_/ /\___/\___/\__/
                              /___/

<

QUICK-START
object.vim is an object-oriented framework for plugin writers of Vim. It aims
to augment and enrich the existing techniques for OOP in Vim. That means
instead of doing this:
>
  let s:MyAwesomeClass = {}
<
you can do this:
>
  let s:MyAwesomeClass = object#class('MyAwesomeClass')
<
And yes, you type the class name twice, but here is the prizes:
>
  echo object#repr(s:MyAwesomeClass)
  <type 'MyAwesomeClass'>

  let awesome = object#new(s:MyAwesomeClass)
  echo object#repr(awesome)
  <'MyAwesomeClass' object>
<

What you get is a type that works out of the box instead of a plain |Dict|.
There is a lot more you can do with object.vim, such as multiple inheritance.
Although people nearly always frown on madly complicated class hierarchy,
object.vim make it possible for you to make people mad :). Powered by
C3-linearization, you get exactly the same MRO as examplified by
|https://rhettinger.wordpress.com/2011/05/26/super-considered-super/|:
>
  let s:LoggingDict = object#class('LoggingDict', somedict)
  let s:LoggingOD = object#class('LoggingOD', [s:LoggingDict, s:OrderedDict)

  echo object#repr(s:LoggingOD.__mro__)
  [<type 'LoggingOD'>,
   <type 'LoggingDict'>,
   <type 'OrderedDict'>,
   <type, 'somedict'>,
   <type, 'object'>]
<

And yes, you can use `super()` with a little more verbosity:
>
  let s:Shape = object#class('Shape')
  function! s:Shape.__init__(shapename, ...)
    let self.shapename = a:shapename
    call call(object#super(s:Shape, self, '__init__'), a:000)
  endfunction

  let s:ColoredShape = object#class('ColoredShape', s:Shape)
  function! s:ColoredShape.__init__(color, ...)
    let self.color = a:color
    call call(object#super(s:ColoredShape, self, '__init__'), a:000)
  endfunction
<
Note that to avoid differing signature problems in the chained calls of
`super()`, the above cooperative methods take arbitrary number of arguments,
which produces the `call` `call(...)` verbosity. It can be made brief by using
a |Dict| as argument:
>
  let s:Shape = object#class('Shape')
  function! s:Shape.__init__(kwdict)
    let self.shapename = get(a:kwdict, 'shapename')
    call object#super(s:Shape, self, '__init__')(a:kwdict)
  endfunction

  let s:ColoredShape = object#class('ColoredShape', s:Shape)
  function! s:ColoredShape.__init__(kwdict)
    let self.color = get(a:kwdict, 'color')
    call object#super(s:ColoredShape, self, '__init__')(a:kwdict)
  endfunction
<

FEATURES
object.vim implements its features in the following modules:

  * class:    inheritance and instantiation.
  * iter:     iterator for |List| and |String| and helper functions.
  * file:     plain old file object for line-oriented I/O.
  * lambda:   create one-liner easily and `for()` loop construct.
  * mapping:  hash arbitrary object and generic `getitem()`, `setitem()`.
  * types:    top level classes like `object`, `type` and conversion protocols
    like `bool()`.

Note that although these features are implemented in separate files, they are
kind-of imported into a shallow namespace for the ease of use so please use
`object#class()` instead of `object#class#class()`. Please consider everything
in namespaces deeper than `object` as implementation details and avoid using
them as much as you can. However, each individual function is still documented
with its full name, as found in |object.vim-functions|.

TESTING
I use `vader.vim` for unit tests. A comprehensive test suite for each module
can be found in `object.vim/test`. To run all the test, use:
>
  object.vim/test/run-tests.sh
<

DEPENDENCY
  * `vim-maktaba`: |https://github.com/google/vim-maktaba|, version >= 1.16.0
  * `vader.vim`: |https://github.com/junegunn/vader.vim|
  * `Vim`: version >= 7.4

AUTHOR
  * author: cgsdfc
  * email: cgsdfc@126.com

There are a lot more interesting stuffs about object.vim. Read on.

==============================================================================
PROTOCOLS                                               *object.vim-protocols*

A set of basic hookable functions that inspect and operate on different
properties of an object. A protocol in this context means an global function
that has well defined behaviours for built-in types and can be overriden by
the corresponding methods with double underscores names.

==============================================================================
CLASS                                                       *object.vim-class*

This module provides functions for the creation and manipulation of classes
and instances. Below, the term "class" is used interchangably with "type" to
refer to the object representing a class, since there is no "old-style" class
in object.vim. Every class is derived from `object` (except `object`). The
term "class object" is avoided since it reminds people of the "old-style"
class.

COMPARED-WITH-RELATED-APPROACHES
There are different approaches to create classes in Vimscript. To get the best
of them, we compare them and show design rationales of object.vim at the same
time.

The most common approach is via a simple assignment:
>
  let s:MyClass = {}
  function! s:MyClass.some_method()
    " some code
  endfunction

  let var = deepcopy(s:MyClass)
<
This approach has the virtue of being brief, but obviously a plain `{}` can't
have too much features.

Here is a command-based approach:
>
  Class MyClass, some_bases
    " some methods
  EndClass
<
This approach introduces new commands that begins and ends the class
definition. It looks very like a DSL, which goes against the aim of
object.vim, which says no new syntax is required.

Another approach defines all the methods inside a function that creates the
class:
>
  function! s:GetMyClass()
    let s:MyClass = {}
    function! s:MyClass.some_method()
      " some code
    endfunction
    " more methods
    return deepcopy(s:MyClass)
  endfunction
<
This approach looks nice as it bundles all the methods together. However, it
mixes together the definition of a class and the instantiation of it, making
both aspects less flexible.

With these limitations in mind, object.vim is designed to be intuitively
usable yet very flexible:
>
  let s:Logger = object#class('Logger')

  function! s:Logger.info(...)
    return self.log('info', a:000)
  endfunction
<

MULTIPLE-INHERITANCE
Many people go against MI (Multiple Inheritance) because it complicates the
program. Nonetheless, it it more expressive than single inheritance. That's
why it is supported.

The functions that deal with MI is `class()`, `type()` and `super()`. Both
`class()` and `type()` takes an optional `bases` argument which can be:
  * omitted: derived from `object`.
  * a single class: derived from that.
  * a |List| of classes: derived from all those classes.
  * an empty list: the same as omitted.

Note that the resulting class takes a copy of the base list so you are free to
modify it after `class()` returns.

With MI comes MRO (Method Resolution Order) and C3 algorithm is used to
construct the `__mro__` attribute for each class.  Methods are resolved
statically based on `__mro__`, which means the changes to `__bases__` will not
cause a rerun of method resolution. All the attributes from parents are added
to their child respecting its `__mro__`, which can be overridden naturally by
adding methods with the same names. This means you can call parents' methods
in several ways:
>
  let s:Animal = object#class('Animal')
  function! s:Animal.make_sound()
    echo 'Animal makes sound'
  endfunction

  let s:Dog = object#class('Dog', s:Animal)
  function! s:Dog.bark()
    call self.make_sound()
    echo 'Dog barks'
  endfunction

  let dog = object#new(s:Dog)
  call dog.make_sound()
  Animal makes sound

  echo has_key(dog, 'make_sound')
  1
<
However, if the child is overriding a method of its parents, it can only call
the parents' version with `super()`, which will look up methods in parents or
siblings for you:
>
  function! s:Dog.make_sound()
    call object#super(s:Dog, self, 'make_sound')()
    echo 'Dog makes sound'
  endfunction

  call dog.make_sound()
  Animal makes sound
  Dog makes sound
<
What surprises you is that the `super()` does not return a proxy object but
just a plain |Funcref|, which deviates the spirit of "everything is an
object". This is a trade-off of convenience and efficiency. Creating a super
object is expensive since for those attributes to be present, we have to put
them into the super object and due to the chained-calling nature of `super()`,
multiple super objects may be created during one call to `super()`. We can
create them lazily and cache them in each instance, but that adds complexity
to the implementation. Yet hopefully, this will be implemented in the future
as it looks and feels better than the current `super()`. Compare:
>
 call object#super(s:MyClass, self).__init__()
 call object#super(s:MyClass, self, '__init__')()
<
The second one looks just stupid.


SPECIAL-ATTRIBUTES
Like Python, object.vim uses double-underscored names for special attributes.
The use of such attributes in the class modules aims to be minimal, as it
takes space off every class and instance. Currently, these are:

Class:
  * __name__: the name of the class, a valid identifier.
  * __base__: the first direct base.
  * __bases__: the list of direct bases.
  * __mro__: the list of method resolution order.
  * __class__: currently always the `type` class.

Instance:
  * __class__: the type of this instance.


ATTRIBUTES
We have been talking about attributes, but what are they in the context of
object.vim? Basically everything inside a |Dict| with its name as an
identifier is an attribute. Particularly, if the attribute is a |Funcref|, it
is treated as instance methods. This is important since when an instance is
created, it will have all the |Funcref| attributes of its class as its
methods. Anything other than |Funcref| stays in the class as it, which
implies:
  * A class cannot have `classmethod`. You should not call methods on a class.
  * A class can have its own attributes, as long as they are not |Funcref|.

The lack of `classmethod` sounds discouraging because classes are no longer
first-class object and they will fail with some protocols. That may be
improved in the future.

CLASS-NAME-AND-IDENTITY
There is no notion of class-registry in object.vim and the `name` argument got
passed to `class()` is not checked for uniqueness. This means it is possible
for two different class to have the same name. However, as long as the
variables holding the classes have distinct names, there won't be name
crashes. What's more, every class will have different identities testable by
`is#` since `class()` always creates new class. As currently the name of a
class is only used to provide its `repr()` (not as the key to anything), you
are free to crash your class names with other's without a doubt :-).

EXPOSING-CLASS
As you write plugins you may wish to let others extend or instantiate your
classes. Here are the ways to do so:
>
  " You can do this:
  function! useful#Formatter_()
    return s:Formatter
  endfunction

  " so that user can inherit your class
  let s:useful_Formater = useful#Formatter_()
  let s:MyFormatter = object#class('MyFormatter', s:useful_Formater)

  " and instantiate it.
  let formatter = object#new(s:useful_Formater)

  " You can also do this:
  function! useful#Formatter(...) abort
    return object#new_(s:Formatter, a:000)
  endfunction

  " to feel more like a constructor:
  let formatter = useful#Formatter()
<

==============================================================================
MAPPING                                                   *object.vim-mapping*

An interface to key-value containers. A mapping is an object that supports
accessing its values through a set of keys or in short, the subscription
operator. The built-in |String|, |Dict| and |List| can all be viewed as
mapping. This idea is generalized by the functions provided.

Features:
  * Hookable hash() works for built-in types.
  * Hookable getitem() and setitem() functions works built in types.

==============================================================================
ITERATOR                                                     *object.vim-iter*

Iterator protocol.

Features:
  * Vim-compatible map() and filter() that works with iterators.
  * dict() creates |Dict| from an iterator and a lambda, which is similar to
    dict comprehension.
  * filter() evaluates lambda using |object#types#bool()|.
  * Provide iterators for |String| and |List| that works transparently.
  * Helpers like sum(), all(), any(), zip() and enumerate() all work as
    expected.

Examples:
>
  :echo object#all(range(10))
  0

  :echo object#list(object#enumerate('abc'))
  [[0, 'a'], [1, 'b'], [2,'c']]

  :echo object#dict('abc', '[toupper(v:val), v:val]')
  {'A': 'a', 'B': 'b', 'C': 'c'}

  :echo object#dict(object#enumerate('abc'), '[v:val[1], v:val[0]]')
  {'a': 0, 'b': 1, 'c': 2}

  :echo object#dict(object#zip('abc', range(3)))
  {'a': 0, 'b': 1, 'c': 2}

  :echo object#sum(range(1, 100))
  5050

  :echo object#filter(['1', '2', ''], 'v:val')
  ['1', '2']

  :echo object#list('abc')
  ['a', 'b', 'c']
<

Limitations:
  * No generator and yield() supported.

==============================================================================
FILE                                                         *object.vim-file*

A simple interface to the |readfile()| and |writefile()| functions.

Features:
  * Lazy reading and writing.
  * Line-oriented I/O.
  * Handle errors with IOError.
  * Mode string syntax like 'a', 'w' or '+', 'b'.

Limitations:
  * The file is always buffered.
  * The content of the file object is not synchronized with external changes
    to the underlying file.
  * The file is unseekable. All reading or writing happens essentially at the
    current line number.
  * No context manager available. Must call f.close() explicitly or you may
    lost written data.

Note:
  * Unlike the counterparts from Python, readlines() always strips tailing
    newlines and
  * writelines() always adds tailing newlines.

Examples:
>
  Your file is
  1
  2
  3
  :echo f.readlines()
  ['1', '2', '3']

  :call f.writelines(range(3))
  :call f.close()
  Your file becomes
  1
  2
  3
<
This is rooted at the nature of |readfile()| and |writefile()|.

==============================================================================
TYPES                                                       *object.vim-types*

Define a minimal set of fundamental types as the basic of the type hierarchy.
They are:
  * object(None): The base class of all the rest of classes. The base class of
    it is None, the only instance of the NoneType.

  * type(object): The class of all the types for both built-in and user
    definded ones. In other words, every class is an instance of type.

  * NoneType(type): The class of the None object, the place holder for absence
    of sensible values, such as the base class of object.

==============================================================================
LAMBDA                                                     *object.vim-lambda*

Create inline function in one line of code. It is an enhanced version of
|maktaba#function#FromExpr()|.

Features:
  * `lambda()` returns a |Funcref| rather than a |Dict|, which can be used
    directly in situation such as |sort()|.
  * The created lambda uses named arguments rather than numbered arguments
    like `a:1`, improving readability.
  * Provide interface to the underlying lambda object via `lambda_()`.
  * lambda can create closure if one want to.
  * `for()` function let you execute nearly arbitrary code while iterating.

Limitations:
  * No closure for the code segments executed in the for() function.
  * Only one dictionary can be captured as closure at most, which means you
    cannot access both `s:` and `l:` from the lambda at once. But there is a
    simple workaround for this: > :let both_s_and_l = { 's': s:, 'l': l: }
    :echo object#lambda('x', 'x > 1 ? c.s.var : l.s.var')(1) <
  * The number of arguments to the lambda is limited by the maximum number
    allowed by Vim.

Examples:
>
  :echo object#lambda('x y', 'x + y')(1, 2)
  3

  :echo sort(range(10), object#lambda('x y', 'y - x'))
  [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

  :echo object#map('aaa', object#lambda('s', 'toupper(s)'))
  'AAA'

  :call object#for('key val', object#enumerate([1, 2]), 'echo key val')
  0 1
  1 2

  :let f = object#lambda_('x y', 'x + y')
  :echo object#repr(f)
  <'lambda' object>
  :echo f.__call__(1, 2)
  3
<

==============================================================================
DICTIONARIES                                                *object.vim-dicts*

                                                             *object.vim.file*

file.read()                                                      *file.read()*
  Read the the whole of the file, return it as a string. Lines are joint with
  a NL character.

file.readline()                                              *file.readline()*
  Return the next line from the file. Return an empty string at EOF.

  Note: Newlines are stripped.

file.readlines()                                            *file.readlines()*
  Return a list of strings, each a line from the file.

  Note: Newlines are stripped.

file.write({str})                                               *file.write()*
  Write a {str} to the file. {str} is appended to the last line of file.

  Note: If {str} becomes the first line of the file, a newline will be added
  right after this line as if it is done with writeline().

file.writeline({line})                                      *file.writeline()*
  Write a {line} to the file.

file.writelines({iter})                                    *file.writelines()*
  Write a sequence of strings to the file.
  Throws ERROR(WrongType) if {iter} returns non-string.

file.flush()                                                    *file.flush()*
  Flush the written data.
  Throws ERROR(IOError) if |writefile()| fails.

file.close()                                                    *file.close()*
  Close the file and flush it. After that any file operation will fail.
  Calling close() multiple times does not causes errors.

file.readable()                                              *file.readable()*
  Return whether the file is opened for reading.

file.writable()                                              *file.writable()*
  Return whether the file is opened for writing.

file.__bool__()                                              *file.__bool__()*
  __bool__(file) <==> file is not closed.

file.__iter__()                                              *file.__iter__()*
  __iter__(file) <==> each line of file.

file.__init__({name}, {mode})                                *file.__init__()*
  Initialize a file object with {name} and {mode}.
  Throws ERROR(WrongType) if {mode} is not a String.
  Throws ERROR(ValueError) is {mode} string is invalid.
  Throws ERROR(IOError) if the file is not readable or writable.

file.__repr__()                                              *file.__repr__()*
  __repr__(file) <==> repr(file)

                                                           *object.vim.lambda*

lambda.__init__({names}, {code}, [closure])                *lambda.__init__()*
  Initialize the |object.vim.lambda| object from a |String| of names to be
  used as the names of the function arguments and the expression to evaluated.

  If a [closure] is given, it can be accessed in form of `c.var` in the {code}
  argument. The letter `c` is chosen because it is the first letter for
  "capture", "capital" and "closure", all to do with `function`. What's more,
  the `c.var` syntax minics the `a:var`, `s:var` convensions of Vim, which
  makes it easier to remember. After all, it is short and meaningful so let's
  use it!

  Throws ERROR(ValueError) if {names} is not a |name-specification|.
  Throws ERROR(WrongType) if {code} or {names} is not a |String| or
  [closure] is not a |Dict|.

lambda.__call__([args])                                    *lambda.__call__()*
  Evaluate the lambda expression by applying [args].

  Throws ERROR(TypeError) if the actual arguments do not match the
  formal arguments declared via names.

==============================================================================
FUNCTIONS                                               *object.vim-functions*

object#class#class({name}, [bases])                     *object#class#class()*
  Define a class that has a {name} and optional [bases].

  {name} should be a |String| of valid identifier. [bases] should be a class
  or a |List| of classes. If no [bases] are given or [bases] is an empty
  |List|, the new class will subclass `object`.

  Return the newly created class with inherited attributes.

object#class#new({cls}, [args])                           *object#class#new()*
  Create a new instance of {cls} applying [args].

  The `__init__` method will be called with [args].

object#class#new_({cls}, {args})                         *object#class#new_()*
  Create a new instance of {cls} applying {args}.

  You can wrap it to write a constructor-like function:
>
    function! MyClass(...)
      return object#new_(s:MyClass, a:000)
    endfunction
<

objec#class#type([args])                                 *object#class#type()*
  Return the type of an object or create a new type dynamically.

  type(obj) -> obj.__class__

  type(name, bases, dict) -> a new type.

object#class#super({type}, {obj}, {name})               *object#class#super()*
  Retrieve method {name} bound to {obj} from the parent or sibling of {type}.

  Require object#isinstance({obj}, {type}) to be true.

  Require {type} is not the last class in the mro of {obj}.

  Require the attribute {name} is a |Funcref|.

object#class#isinstance({obj}, {cls})              *object#class#isinstance()*
  Return whether {obj} is an instance of {cls}.

object#class#issubclass({cls}, {base})             *object#class#issubclass()*
  Return whether {cls} is a subclass of {base}.

object#except#BaseException({type}, {msg}, {args})
                                               *object#except#BaseException()*
  Generate exception for a specific {type}. User can call BaseException to
  define their own exception functions. Examples:
>
    function! MyException(msg, ...)
      return object#BaseException('MyException', a:msg, a:000)
    endfunction
<

object#file#open({name}, [mode])                          *object#file#open()*
  Open a file. The [mode] can be 'r', 'w' or 'a' for reading (default),
  writing or appending. The file will be created if it doesn't exist when
  opened for writing or appending; it will be truncated when opened for
  writing. Add a 'b' to the [mode] for binary files. Add a '+' to the [mode]
  to allow simultaneous reading and writing.

object#iter#iter({obj})                                   *object#iter#iter()*
  Return an iterator from {obj}. If {obj} is already an iterator, it is
  returned as it. Built-in |List| and |String| have iterators. An __iter__
  method of {obj} that returns an iterator will be used if possible.

  Throws ERROR(WrongType) if {obj} has an unusable __next__.
  Throws ERROR(TypeError) if the __iter__ of {obj} does not return an
  iterator.

object#iter#next({obj})                                   *object#iter#next()*
  Retrieve the next item from the iterator {obj}.

object#iter#any({iter})                                    *object#iter#any()*
  Return true iff any item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#all({iter})                                    *object#iter#all()*
  Return true iff all item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#enumerate({iter}, [start])               *object#iter#enumerate()*
  Return an iterator for index, value of {iter} Take an optional [start].

object#iter#zip({iter}, [iters])                           *object#iter#zip()*
  Return an iterator that returns [seq1[i], seq[i], ...] for the ith call of
  object#next(). The iterator stops when the first StopIteration is raised by
  one of the [iters].

object#iter#map({iter}, {lambda})                          *object#iter#map()*
  Create a new list by applying {lambda} to each item of an {iter}. {lambda}
  should be a |String| that is acceptable by built-in |map()|.

object#iter#filter({iter}, {lambda})                    *object#iter#filter()*
  Create a new list by removing the item from {iter} when {lambda} return
  false. Truthness is evaluated by object#bool(). {lambda} should be a
  |String| that is acceptable by built-in |filter()|.

object#iter#sum({iter}, [start])                           *object#iter#sum()*
  Return the sum of items from {iter} plus the value of parameter [start],
  which defaults to 0. Items must be either |Number|s or |Float|s, i.e.,
  numeric. If {iter} is empty, [start] is returned.

  Throws ERROR(WrongType) if any item is not numeric.

object#lambda#lambda()                                *object#lambda#lambda()*
  Create a one-line |Funcref| that takes names as arguments and returns the
  result of evaluation of code.

  If a closure argument is given, the variables `var` living inside the
  closure are available as `c.var` from the lambda expression.


object#lambda#lambda_()                              *object#lambda#lambda_()*
  Create a lambda object that cannot be directly called but has a `__call__`
  method, which does the same thing as what is returned by `object#lambda()`.

object#lambda#for({iterable}, {names}, {cmd})            *object#lambda#for()*
  Execute a |List| of commands while iterating over {iterable}. {names} is a
  space-separated |String|s that contains the variable names used as the items
  in the {iterable}.

  {cmd} is a |String| of Ex command or a |List| of such strings. During each
  iteration, the commands are executed in the order that they are specified in
  the list. Examples:
>
    call object#for('x', range(10), ['if x > 0', 'echo x', 'endif'])
    call object#for('f', files, 'call f.close()')
    call object#for('key val', items({'a': 1}), 'echo key val')
<

object#mapping#hash({obj})                             *object#mapping#hash()*
  Return the hash value of {obj}. {obj} can be a |Number|, a |String| a
  |Funcref| or special variables like |v:none| and |v:false|, or an object
  with __hash__() defined.

  Throws ERROR(TypeError) if hash() is not possible for {obj}.
  Throws ERROR(WrongType) if __hash__ is not a |Funcref| or returns
  something NAN (Not A Number).

object#mapping#getitem({obj}, {key})                *object#mapping#getitem()*
  Return the value at {key} in {obj} as if {obj} is a mapping. If {obj} is a
  |List|, |String| or plain |Dict|, checked-version of built-in subscription
  will be called. Vim error about |List| index will translate to
  @exception(IndexError). Vim's ignorance about the index to |String| will be
  augmented by checking the emptiness of the value.

  Throws ERROR(WrongType) if {obj} is a |String| or |List| but {key} is not a
  |Number| or {obj} is a |Dict| but {key} is not a |String|.

  Throws ERROR(IndexError) if {key} is out of range for |String| or |List|.
  Throws ERROR(KeyError) if {key} is not present in the |Dict|.

object#mapping#setitem({obj}, {key}, {val})         *object#mapping#setitem()*
  Set the value at {key} of {obj} to {val}. If {obj} is a |List|, |String| or
  a |Dict|, subscription version of |let| will be uesd. Otherwise, __setitem__
  of {obj} will be used.

object#protocols#getattr({obj}, {name})           *object#protocols#getattr()*
  Get the attribute {name} from {obj}. Note: The __getattr__() hook overrides
  the dictionary lookup completely. That means it is not consulted after
  dictionary lookup failed but used directly if there is a usable one.


object#protocols#setattr({obj}, {name}, {val})    *object#protocols#setattr()*
  Set the {name} attribute of {obj} to {val}.


object#protocols#hasattr({obj}, {name})           *object#protocols#hasattr()*
  Test whether {obj} has attribute {name}. Return false if {obj} is not a
  |Dict|.


object#protocols#repr({obj})                         *object#protocols#repr()*
  Generate string representation for {obj}. Fail back on |string()|


object#protocols#len({obj})                           *object#protocols#len()*
  Return the length of {obj}. If {obj} is a |List| or a |Dict|, |len()| will
  be called. Otherwise, the __len__() of {obj} will be called.


object#protocols#dir({obj})                           *object#protocols#dir()*
  Return a |List| of names of all attributes from {obj}. If {obj} defines
  __dir__(), it is called instead.


object#types#object()                                  *object#types#object()*
  Create a plain object.

object#types#object_()                                *object#types#object_()*
  Return the object class

object#types#type_()                                    *object#types#type_()*
  Return the type class

object#types#NoneType()                              *object#types#NoneType()*
  Return the NoneType class

object#types#None()                                      *object#types#None()*
  Return the None object

object#types#dict([iter])                                *object#types#dict()*

>
    dict() -> an empty dictionary.
    dict(iterable) -> initiazed with 2-list items.
    dict(iterable, lambda) -> applies lambda to iterable, initiazed with the
      resulting list.
    dict(plain dictionary) -> a copy of the argument.
<

  Turn an iterator that returns 2-list into a |Dict|. If no [iter] is given,
  an empty |Dict| is returned. If a |Dict| is given, it is effectively
  |copy()|'ed.

object#types#list([iter])                                *object#types#list()*

>
    list() -> an empty list.
    list(iterable) -> initiazed with items of iterable.
<

  Turn an iterator into a |List|. If no [iter] is given, an empty |List| is
  returned. If a |List| is given, it is effectively |copy()|'ed.

==============================================================================
EXCEPTIONS                                             *object.vim-exceptions*

                                                            *ERROR(Exception)*
Generic exception.

                                                           *ERROR(ValueError)*
The value of function arguments went wrong.

                                                            *ERROR(TypeError)*
Unsupported operation for a type or wrong number of arguments passed to a
function.

                                                       *ERROR(AttributeError)*
The object has no such attribute or the attribute is readonly.

                                                        *ERROR(StopIteration)*
The end of iteration. Thrown by __iter__ usually.

                                                           *ERROR(IndexError)*
Index out of range for sequences.

                                                             *ERROR(KeyError)*
Key out of range for sequences.

                                                              *ERROR(IOError)*
File not writable or readable. Operation on a closed file. Thrown by file
objects usually.

==============================================================================
MOTIVATION                                             *object.vim-motivation*

Well the first question that I asked myself at the beginning of this project
is: What? you want to create a DSL in Vim that looks like Python and you
expect those who use pure Python or pure Vimscript for their plugins to like
your hybridization that sounds like Vimthon?

Well first of all, I don't expect people to like my plugin and I just find it
fun to write an OOP framework for Vim. That's my motivation.

Second, I personally don't think it is a DSL because it is just a bunch of
functions that work together. There is no new syntax to learn (which means
extra rules to obey). You just pick up a piece of tool you want to use and it
(should) works out of the box.

Third, I am not doing hybridization like Emacs in Vim or vice versa, which
explains why we have such a limited number of functions compared with the
versatile libraries of Python. Those who expect a complete Python layer over
Vimscript will be disappointed by the fact that not even the standard library
`sys` is found. What's more, some counterparts of Python have different
signatures or even different behaviors, which will be explained in details.
Most of the time, we strive for Python compatibility since that won't surprise
people gravely.

In short, what we provide is an OOP framework that feels familiar to Python
and hopefully, useful for Vim plugin writers.



vim:tw=78:ts=8:ft=help:norl:
