*object.vim.txt*
                                                         *object* *object.vim*

==============================================================================
CONTENTS                                                 *object.vim-contents*
  1. Introduction...........................................|object.vim-intro|
  2. Protocols..........................................|object.vim-protocols|
  3. Class..................................................|object.vim-class|
  4. Mapping..............................................|object.vim-mapping|
  5. Iterator................................................|object.vim-iter|
  6. File....................................................|object.vim-file|
  7. Types..................................................|object.vim-types|
  8. Lambda................................................|object.vim-lambda|
  9. Dictionaries...........................................|object.vim-dicts|
  10. Functions.........................................|object.vim-functions|
  11. Exceptions.......................................|object.vim-exceptions|

==============================================================================
INTRODUCTION                                                *object.vim-intro*


>
                             __      _           __
                      ____  / /_    (_)__  _____/ /_
                     / __ \/ __ \  / / _ \/ ___/ __/
                    / /_/ / /_/ / / /  __/ /__/ /_
                    \____/_.___/_/ /\___/\___/\__/
                              /___/

<
object.vim is a library plugin that provides object protocols for Vim. It aims
to be an augmentation to the built-in function as well as existing coding
convensions, rather than correction or reinvention. To achieve this, it
strives for the following:
  * Always enhance and be compatible with built-in functions.
  * Always works with built-in types.
  * Minimal principle: only core functions are provided.

Keeping this in mind, object.vim tries to built an object-oriented framework
as well as a bunch of useful modules built on top of that. With object.vim you
can create and loop over iterators, read and write files with objects, create
lambda functions with intuitive syntax and hash arbitrary objects. Most
fundamentally, you can define full-fledged classes that seamlessly integrate
with all these protocols.

object.vim also hides some of the dark sides of Vim so a robust and consistent
interface is possible. For the ease of use and code modularity, object.vim put
evarything available to the users in the `object#` namespace and implements
them in the sub-namespace such as `object#file#`. The benefit is that user can
use any functionality as if as they are built-in to object.vim. This also
implies that anything in the sub-namespace of `object#` is implementation
details and subjects to changes, upon which users should not rely.

In terms of API styles, object.vim is loosely based on the common parts of Vim
and Python2. Whenever possible, it strives for simplicity and elegance. It is
also believed that a small core is better a huge code base, which is easier to
understand and make use of.

Happy with the object!


==============================================================================
PROTOCOLS                                               *object.vim-protocols*

A set of basic hookable functions that inspect and operate on different
properties of an object. A protocol in this context means an global function
that has well defined behaviours for built-in types and can be overriden by
the corresponding methods with double underscores names.

==============================================================================
CLASS                                                       *object.vim-class*

functions for creating both classes and instances and testing their
relationships. Inheritance is possible. The methods of base classes are added
from left to right across the [bases] when class() is called. The methods
defined for this class effectively override those from bases.


Features:
  * Multiple inheritance.
  * Calling methods from supers.
  * Type identification.

Drawbacks:
  * Use more space for the house keeping attributes.
  * Takes more time for the class and instance creation.

Limitations:
  * Methods are resolved statically at class creation time, which makes the
    class object even larger.

==============================================================================
MAPPING                                                   *object.vim-mapping*

An interface to key-value containers. A mapping is an object that supports
accessing its values through a set of keys or in short, the subscription
operator. The built-in |String|, |Dict| and |List| can all be viewed as
mapping. This idea is generalized by the functions provided.

Features:
  * Hookable hash() works for built-in types.
  * Hookable getitem() and setitem() functions works built in types.

==============================================================================
ITERATOR                                                     *object.vim-iter*

Iterator protocol.

Features:
  * Vim-compatible map() and filter() that works with iterators.
  * dict() creates |Dict| from an iterator and a lambda, which is similar to
    dict comprehension.
  * filter() evaluates lambda using |object#types#bool()|.
  * Provide iterators for |String| and |List| that works transparently.
  * Helpers like sum(), all(), any(), zip() and enumerate() all work as
    expected.

Examples:
>
  :echo object#all(range(10))
  0

  :echo object#list(object#enumerate('abc'))
  [[0, 'a'], [1, 'b'], [2,'c']]

  :echo object#dict('abc', '[toupper(v:val), v:val]')
  {'A': 'a', 'B': 'b', 'C': 'c'}

  :echo object#dict(object#enumerate('abc'), '[v:val[1], v:val[0]]')
  {'a': 0, 'b': 1, 'c': 2}

  :echo object#dict(object#zip('abc', range(3)))
  {'a': 0, 'b': 1, 'c': 2}

  :echo object#sum(range(1, 100))
  5050

  :echo object#filter(['1', '2', ''], 'v:val')
  ['1', '2']

  :echo object#list('abc')
  ['a', 'b', 'c']
<

Limitations:
  * No generator and yield() supported.

==============================================================================
FILE                                                         *object.vim-file*

A simple interface to the |readfile()| and |writefile()| functions.

Features:
  * Lazy reading and writing.
  * Line-oriented I/O.
  * Handle errors with IOError.
  * Mode string syntax like 'a', 'w' or '+', 'b'.

Limitations:
  * The file is always buffered.
  * The content of the file object is not synchronized with external changes
    to the underlying file.
  * The file is unseekable. All reading or writing happens essentially at the
    current line number.
  * No context manager available. Must call f.close() explicitly or you may
    lost written data.

Note:
  * Unlike the counterparts from Python, readlines() always strips tailing
    newlines and
  * writelines() always adds tailing newlines.

Examples:
>
  Your file is
  1
  2
  3
  :echo f.readlines()
  ['1', '2', '3']

  :call f.writelines(range(3))
  :call f.close()
  Your file becomes
  1
  2
  3
<
This is rooted at the nature of |readfile()| and |writefile()|.

==============================================================================
TYPES                                                       *object.vim-types*

Define a minimal set of fundamental types as the basic of the type hierarchy.
They are:
  * object(None): The base class of all the rest of classes. The base class of
    it is None, the only instance of the NoneType.

  * type(object): The class of all the types for both built-in and user
    definded ones. In other words, every class is an instance of type.

  * NoneType(type): The class of the None object, the place holder for absence
    of sensible values, such as the base class of object.

==============================================================================
LAMBDA                                                     *object.vim-lambda*

Create inline function in one line of code. It is an enhanced version of
|maktaba#function#FromExpr()|.

Features:
  * `lambda()` returns a |Funcref| rather than a |Dict|, which can be used
    directly in situation such as |sort()|.
  * The created lambda uses named arguments rather than numbered arguments
    like `a:1`, improving readability.
  * Provide interface to the underlying lambda object via `lambda_()`.
  * lambda can create closure if one want to.
  * `for()` function let you execute nearly arbitrary code while iterating.

Limitations:
  * No closure for the code segments executed in the for() function.
  * Only one dictionary can be captured as closure at most, which means you
    cannot access both `s:` and `l:` from the lambda at once. But there is a
    simple workaround for this: > :let both_s_and_l = { 's': s:, 'l': l: }
    :echo object#lambda('x', 'x > 1 ? c.s.var : l.s.var')(1) <
  * The number of arguments to the lambda is limited by the maximum number
    allowed by Vim.

Examples:
>
  :echo object#lambda('x y', 'x + y')(1, 2)
  3

  :echo sort(range(10), object#lambda('x y', 'y - x'))
  [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

  :echo object#map('aaa', object#lambda('s', 'toupper(s)'))
  'AAA'

  :call object#for('key val', object#enumerate([1, 2]), 'echo key val')
  0 1
  1 2

  :let f = object#lambda_('x y', 'x + y')
  :echo object#repr(f)
  <'lambda' object>
  :echo f.__call__(1, 2)
  3
<

==============================================================================
DICTIONARIES                                                *object.vim-dicts*

                                                             *object.vim.file*

file.read()                                                      *file.read()*
  Read the the whole of the file, return it as a string. Lines are joint with
  a NL character.

file.readline()                                              *file.readline()*
  Return the next line from the file. Return an empty string at EOF.

  Note: Newlines are stripped.

file.readlines()                                            *file.readlines()*
  Return a list of strings, each a line from the file.

  Note: Newlines are stripped.

file.write({str})                                               *file.write()*
  Write a {str} to the file. {str} is appended to the last line of file.

  Note: If {str} becomes the first line of the file, a newline will be added
  right after this line as if it is done with writeline().

file.writeline({line})                                      *file.writeline()*
  Write a {line} to the file.

file.writelines({iter})                                    *file.writelines()*
  Write a sequence of strings to the file.
  Throws ERROR(WrongType) if {iter} returns non-string.

file.flush()                                                    *file.flush()*
  Flush the written data.
  Throws ERROR(IOError) if |writefile()| fails.

file.close()                                                    *file.close()*
  Close the file and flush it. After that any file operation will fail.
  Calling close() multiple times does not causes errors.

file.readable()                                              *file.readable()*
  Return whether the file is opened for reading.

file.writable()                                              *file.writable()*
  Return whether the file is opened for writing.

file.__bool__()                                              *file.__bool__()*
  __bool__(file) <==> file is not closed.

file.__iter__()                                              *file.__iter__()*
  __iter__(file) <==> each line of file.

file.__init__({name}, {mode})                                *file.__init__()*
  Initialize a file object with {name} and {mode}.
  Throws ERROR(WrongType) if {mode} is not a String.
  Throws ERROR(ValueError) is {mode} string is invalid.
  Throws ERROR(IOError) if the file is not readable or writable.

file.__repr__()                                              *file.__repr__()*
  __repr__(file) <==> repr(file)

                                                           *object.vim.lambda*

lambda.__init__({names}, {code}, [closure])                *lambda.__init__()*
  Initialize the |object.vim.lambda| object from a |String| of names to be
  used as the names of the function arguments and the expression to evaluated.

  If a [closure] is given, it can be accessed in form of `c.var` in the {code}
  argument. The letter `c` is chosen because it is the first letter for
  "capture", "capital" and "closure", all to do with `function`. What's more,
  the `c.var` syntax minics the `a:var`, `s:var` convensions of Vim, which
  makes it easier to remember. After all, it is short and meaningful so let's
  use it!

  Throws ERROR(ValueError) if {names} is not a |name-specification|.
  Throws ERROR(WrongType) if {code} or {names} is not a |String| or
  [closure] is not a |Dict|.

lambda.__call__([args])                                    *lambda.__call__()*
  Evaluate the lambda expression by applying [args].

  Throws ERROR(TypeError) if the actual arguments do not match the
  formal arguments declared via names.

==============================================================================
FUNCTIONS                                               *object.vim-functions*

object#class#class({name}, [bases])                     *object#class#class()*
  Define a class that has a {name} and optional base class(es). {name} should
  be a |String| of valid identifier in Vim. [bases] should be a class object
  or a |List| of class objects. If no [bases] are given or [bases] is an empty
  |List|, the new class will subclass object. Return the newly created class
  with only inherited attributes.

object#class#new({cls}, [args])                           *object#class#new()*
  Create a new instance. This is done by first creating a skeleton object from
  the attributes of the {cls} and then calling __init__ of the newly created
  object with [args].

object#class#new_({cls}, {args})                         *object#class#new_()*
  Create a new instance. Take a |List| as {args} rather than variadic
  arguments.

object#class#type()                                      *object#class#type()*
  type(obj) -> class of obj.

  type(name, bases, dict) -> a new type.

object#class#super({cls}, {obj}, {method})              *object#class#super()*
  Return a method from the direct base {cls} of {obj}. This is done by binding
  the methods of {cls} to {obj}.

  Throws ERROR(TypeError) if {cls} is not a direct base of {obj}.

object#class#isinstance({obj}, {cls})              *object#class#isinstance()*
  Return whether {obj} is an instance of {cls}.

object#class#issubclass({cls}, {base})             *object#class#issubclass()*
  Return wheter {cls} is a subclass of {base}.

object#except#BaseException({type}, {msg}, {args})
                                               *object#except#BaseException()*
  Generate exception for a specific {type}. User can call BaseException to
  define their own exception functions. Examples:
>
    function! MyException(msg, ...)
      return object#BaseException('MyException', a:msg, a:000)
    endfunction
<

object#file#open({name}, [mode])                          *object#file#open()*
  Open a file. The [mode] can be 'r', 'w' or 'a' for reading (default),
  writing or appending. The file will be created if it doesn't exist when
  opened for writing or appending; it will be truncated when opened for
  writing. Add a 'b' to the [mode] for binary files. Add a '+' to the [mode]
  to allow simultaneous reading and writing.

object#iter#iter({obj})                                   *object#iter#iter()*
  Return an iterator from {obj}. If {obj} is already an iterator, it is
  returned as it. Built-in |List| and |String| have iterators. An __iter__
  method of {obj} that returns an iterator will be used if possible.

  Throws ERROR(WrongType) if {obj} has an unusable __next__.
  Throws ERROR(TypeError) if the __iter__ of {obj} does not return an
  iterator.

object#iter#next({obj})                                   *object#iter#next()*
  Retrieve the next item from the iterator {obj}.

object#iter#any({iter})                                    *object#iter#any()*
  Return true iff any item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#all({iter})                                    *object#iter#all()*
  Return true iff all item from {iter} is true. Truthness is evaluated using
  object#bool(). {iter} can be anything iterable.

object#iter#enumerate({iter}, [start])               *object#iter#enumerate()*
  Return an iterator for index, value of {iter} Take an optional [start].

object#iter#zip({iter}, [iters])                           *object#iter#zip()*
  Return an iterator that returns [seq1[i], seq[i], ...] for the ith call of
  object#next(). The iterator stops when the first StopIteration is raised by
  one of the [iters].

object#iter#map({iter}, {lambda})                          *object#iter#map()*
  Create a new list by applying {lambda} to each item of an {iter}. {lambda}
  should be a |String| that is acceptable by built-in |map()|.

object#iter#filter({iter}, {lambda})                    *object#iter#filter()*
  Create a new list by removing the item from {iter} when {lambda} return
  false. Truthness is evaluated by object#bool(). {lambda} should be a
  |String| that is acceptable by built-in |filter()|.

object#iter#sum({iter}, [start])                           *object#iter#sum()*
  Return the sum of items from {iter} plus the value of parameter [start],
  which defaults to 0. Items must be either |Number|s or |Float|s, i.e.,
  numeric. If {iter} is empty, [start] is returned.

  Throws ERROR(WrongType) if any item is not numeric.

object#lambda#lambda()                                *object#lambda#lambda()*
  Create a one-line |Funcref| that takes names as arguments and returns the
  result of evaluation of code.

  If a closure argument is given, the variables `var` living inside the
  closure are available as `c.var` from the lambda expression.


object#lambda#lambda_()                              *object#lambda#lambda_()*
  Create a lambda object that cannot be directly called but has a `__call__`
  method, which does the same thing as what is returned by `object#lambda()`.

object#lambda#for({iterable}, {names}, {cmd})            *object#lambda#for()*
  Execute a |List| of commands while iterating over {iterable}. {names} is a
  space-separated |String|s that contains the variable names used as the items
  in the {iterable}.

  {cmd} is a |String| of Ex command or a |List| of such strings. During each
  iteration, the commands are executed in the order that they are specified in
  the list. Examples:
>
    call object#for('x', range(10), ['if x > 0', 'echo x', 'endif'])
    call object#for('f', files, 'call f.close()')
    call object#for('key val', items({'a': 1}), 'echo key val')
<

object#mapping#hash({obj})                             *object#mapping#hash()*
  Return the hash value of {obj}. {obj} can be a |Number|, a |String| a
  |Funcref| or special variables like |v:none| and |v:false|, or an object
  with __hash__() defined.

  Throws ERROR(TypeError) if hash() is not possible for {obj}.
  Throws ERROR(WrongType) if __hash__ is not a |Funcref| or returns
  something NAN (Not A Number).

object#mapping#getitem({obj}, {key})                *object#mapping#getitem()*
  Return the value at {key} in {obj} as if {obj} is a mapping. If {obj} is a
  |List|, |String| or plain |Dict|, checked-version of built-in subscription
  will be called. Vim error about |List| index will translate to
  @exception(IndexError). Vim's ignorance about the index to |String| will be
  augmented by checking the emptiness of the value.

  Throws ERROR(WrongType) if {obj} is a |String| or |List| but {key} is not a
  |Number| or {obj} is a |Dict| but {key} is not a |String|.

  Throws ERROR(IndexError) if {key} is out of range for |String| or |List|.
  Throws ERROR(KeyError) if {key} is not present in the |Dict|.

object#mapping#setitem({obj}, {key}, {val})         *object#mapping#setitem()*
  Set the value at {key} of {obj} to {val}. If {obj} is a |List|, |String| or
  a |Dict|, subscription version of |let| will be uesd. Otherwise, __setitem__
  of {obj} will be used.

object#protocols#getattr({obj}, {name})           *object#protocols#getattr()*
  Get the attribute {name} from {obj}. Note: The __getattr__() hook overrides
  the dictionary lookup completely. That means it is not consulted after
  dictionary lookup failed but used directly if there is a usable one.


object#protocols#setattr({obj}, {name}, {val})    *object#protocols#setattr()*
  Set the {name} attribute of {obj} to {val}.


object#protocols#hasattr({obj}, {name})           *object#protocols#hasattr()*
  Test whether {obj} has attribute {name}. Return false if {obj} is not a
  |Dict|.


object#protocols#repr({obj})                         *object#protocols#repr()*
  Generate string representation for {obj}. Fail back on |string()|


object#protocols#len({obj})                           *object#protocols#len()*
  Return the length of {obj}. If {obj} is a |List| or a |Dict|, |len()| will
  be called. Otherwise, the __len__() of {obj} will be called.


object#protocols#dir({obj})                           *object#protocols#dir()*
  Return a |List| of names of all attributes from {obj}. If {obj} defines
  __dir__(), it is called instead.


object#types#object()                                  *object#types#object()*
  Create a plain object.

object#types#object_()                                *object#types#object_()*
  Return the object class

object#types#type_()                                    *object#types#type_()*
  Return the type class

object#types#NoneType()                              *object#types#NoneType()*
  Return the NoneType class

object#types#None()                                      *object#types#None()*
  Return the None object

object#types#dict([iter])                                *object#types#dict()*

>
    dict() -> an empty dictionary.
    dict(iterable) -> initiazed with 2-list items.
    dict(iterable, lambda) -> applies lambda to iterable, initiazed with the
      resulting list.
    dict(plain dictionary) -> a copy of the argument.
<

  Turn an iterator that returns 2-list into a |Dict|. If no [iter] is given,
  an empty |Dict| is returned. If a |Dict| is given, it is effectively
  |copy()|'ed.

object#types#list([iter])                                *object#types#list()*

>
    list() -> an empty list.
    list(iterable) -> initiazed with items of iterable.
<

  Turn an iterator into a |List|. If no [iter] is given, an empty |List| is
  returned. If a |List| is given, it is effectively |copy()|'ed.

==============================================================================
EXCEPTIONS                                             *object.vim-exceptions*

                                                            *ERROR(Exception)*
Generic exception.

                                                           *ERROR(ValueError)*
The value of function arguments went wrong.

                                                            *ERROR(TypeError)*
Unsupported operation for a type or wrong number of arguments passed to a
function.

                                                       *ERROR(AttributeError)*
The object has no such attribute or the attribute is readonly.

                                                        *ERROR(StopIteration)*
The end of iteration. Thrown by __iter__ usually.

                                                           *ERROR(IndexError)*
Index out of range for sequences.

                                                             *ERROR(KeyError)*
Key out of range for sequences.

                                                              *ERROR(IOError)*
File not writable or readable. Operation on a closed file. Thrown by file
objects usually.


vim:tw=78:ts=8:ft=help:norl:
